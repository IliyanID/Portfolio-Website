{"ast":null,"code":"'use strict';\n\nconst Transform = require('stream').Transform;\n/**\n * MessageParser instance is a transform stream that separates message headers\n * from the rest of the body. Headers are emitted with the 'headers' event. Message\n * body is passed on as the resulting stream.\n */\n\n\nclass MessageParser extends Transform {\n  constructor(options) {\n    super(options);\n    this.lastBytes = Buffer.alloc(4);\n    this.headersParsed = false;\n    this.headerBytes = 0;\n    this.headerChunks = [];\n    this.rawHeaders = false;\n    this.bodySize = 0;\n  }\n  /**\n   * Keeps count of the last 4 bytes in order to detect line breaks on chunk boundaries\n   *\n   * @param {Buffer} data Next data chunk from the stream\n   */\n\n\n  updateLastBytes(data) {\n    let lblen = this.lastBytes.length;\n    let nblen = Math.min(data.length, lblen); // shift existing bytes\n\n    for (let i = 0, len = lblen - nblen; i < len; i++) {\n      this.lastBytes[i] = this.lastBytes[i + nblen];\n    } // add new bytes\n\n\n    for (let i = 1; i <= nblen; i++) {\n      this.lastBytes[lblen - i] = data[data.length - i];\n    }\n  }\n  /**\n   * Finds and removes message headers from the remaining body. We want to keep\n   * headers separated until final delivery to be able to modify these\n   *\n   * @param {Buffer} data Next chunk of data\n   * @return {Boolean} Returns true if headers are already found or false otherwise\n   */\n\n\n  checkHeaders(data) {\n    if (this.headersParsed) {\n      return true;\n    }\n\n    let lblen = this.lastBytes.length;\n    let headerPos = 0;\n    this.curLinePos = 0;\n\n    for (let i = 0, len = this.lastBytes.length + data.length; i < len; i++) {\n      let chr;\n\n      if (i < lblen) {\n        chr = this.lastBytes[i];\n      } else {\n        chr = data[i - lblen];\n      }\n\n      if (chr === 0x0a && i) {\n        let pr1 = i - 1 < lblen ? this.lastBytes[i - 1] : data[i - 1 - lblen];\n        let pr2 = i > 1 ? i - 2 < lblen ? this.lastBytes[i - 2] : data[i - 2 - lblen] : false;\n\n        if (pr1 === 0x0a) {\n          this.headersParsed = true;\n          headerPos = i - lblen + 1;\n          this.headerBytes += headerPos;\n          break;\n        } else if (pr1 === 0x0d && pr2 === 0x0a) {\n          this.headersParsed = true;\n          headerPos = i - lblen + 1;\n          this.headerBytes += headerPos;\n          break;\n        }\n      }\n    }\n\n    if (this.headersParsed) {\n      this.headerChunks.push(data.slice(0, headerPos));\n      this.rawHeaders = Buffer.concat(this.headerChunks, this.headerBytes);\n      this.headerChunks = null;\n      this.emit('headers', this.parseHeaders());\n\n      if (data.length - 1 > headerPos) {\n        let chunk = data.slice(headerPos);\n        this.bodySize += chunk.length; // this would be the first chunk of data sent downstream\n\n        setImmediate(() => this.push(chunk));\n      }\n\n      return false;\n    } else {\n      this.headerBytes += data.length;\n      this.headerChunks.push(data);\n    } // store last 4 bytes to catch header break\n\n\n    this.updateLastBytes(data);\n    return false;\n  }\n\n  _transform(chunk, encoding, callback) {\n    if (!chunk || !chunk.length) {\n      return callback();\n    }\n\n    if (typeof chunk === 'string') {\n      chunk = Buffer.from(chunk, encoding);\n    }\n\n    let headersFound;\n\n    try {\n      headersFound = this.checkHeaders(chunk);\n    } catch (E) {\n      return callback(E);\n    }\n\n    if (headersFound) {\n      this.bodySize += chunk.length;\n      this.push(chunk);\n    }\n\n    setImmediate(callback);\n  }\n\n  _flush(callback) {\n    if (this.headerChunks) {\n      let chunk = Buffer.concat(this.headerChunks, this.headerBytes);\n      this.bodySize += chunk.length;\n      this.push(chunk);\n      this.headerChunks = null;\n    }\n\n    callback();\n  }\n\n  parseHeaders() {\n    let lines = (this.rawHeaders || '').toString().split(/\\r?\\n/);\n\n    for (let i = lines.length - 1; i > 0; i--) {\n      if (/^\\s/.test(lines[i])) {\n        lines[i - 1] += '\\n' + lines[i];\n        lines.splice(i, 1);\n      }\n    }\n\n    return lines.filter(line => line.trim()).map(line => ({\n      key: line.substr(0, line.indexOf(':')).trim().toLowerCase(),\n      line\n    }));\n  }\n\n}\n\nmodule.exports = MessageParser;","map":{"version":3,"sources":["C:/Users/Iliyan/Documents/GitHub/Portfolio-Website/Front-End/node_modules/nodemailer/lib/dkim/message-parser.js"],"names":["Transform","require","MessageParser","constructor","options","lastBytes","Buffer","alloc","headersParsed","headerBytes","headerChunks","rawHeaders","bodySize","updateLastBytes","data","lblen","length","nblen","Math","min","i","len","checkHeaders","headerPos","curLinePos","chr","pr1","pr2","push","slice","concat","emit","parseHeaders","chunk","setImmediate","_transform","encoding","callback","from","headersFound","E","_flush","lines","toString","split","test","splice","filter","line","trim","map","key","substr","indexOf","toLowerCase","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst Transform = require('stream').Transform;\n\n/**\n * MessageParser instance is a transform stream that separates message headers\n * from the rest of the body. Headers are emitted with the 'headers' event. Message\n * body is passed on as the resulting stream.\n */\nclass MessageParser extends Transform {\n    constructor(options) {\n        super(options);\n        this.lastBytes = Buffer.alloc(4);\n        this.headersParsed = false;\n        this.headerBytes = 0;\n        this.headerChunks = [];\n        this.rawHeaders = false;\n        this.bodySize = 0;\n    }\n\n    /**\n     * Keeps count of the last 4 bytes in order to detect line breaks on chunk boundaries\n     *\n     * @param {Buffer} data Next data chunk from the stream\n     */\n    updateLastBytes(data) {\n        let lblen = this.lastBytes.length;\n        let nblen = Math.min(data.length, lblen);\n\n        // shift existing bytes\n        for (let i = 0, len = lblen - nblen; i < len; i++) {\n            this.lastBytes[i] = this.lastBytes[i + nblen];\n        }\n\n        // add new bytes\n        for (let i = 1; i <= nblen; i++) {\n            this.lastBytes[lblen - i] = data[data.length - i];\n        }\n    }\n\n    /**\n     * Finds and removes message headers from the remaining body. We want to keep\n     * headers separated until final delivery to be able to modify these\n     *\n     * @param {Buffer} data Next chunk of data\n     * @return {Boolean} Returns true if headers are already found or false otherwise\n     */\n    checkHeaders(data) {\n        if (this.headersParsed) {\n            return true;\n        }\n\n        let lblen = this.lastBytes.length;\n        let headerPos = 0;\n        this.curLinePos = 0;\n        for (let i = 0, len = this.lastBytes.length + data.length; i < len; i++) {\n            let chr;\n            if (i < lblen) {\n                chr = this.lastBytes[i];\n            } else {\n                chr = data[i - lblen];\n            }\n            if (chr === 0x0a && i) {\n                let pr1 = i - 1 < lblen ? this.lastBytes[i - 1] : data[i - 1 - lblen];\n                let pr2 = i > 1 ? (i - 2 < lblen ? this.lastBytes[i - 2] : data[i - 2 - lblen]) : false;\n                if (pr1 === 0x0a) {\n                    this.headersParsed = true;\n                    headerPos = i - lblen + 1;\n                    this.headerBytes += headerPos;\n                    break;\n                } else if (pr1 === 0x0d && pr2 === 0x0a) {\n                    this.headersParsed = true;\n                    headerPos = i - lblen + 1;\n                    this.headerBytes += headerPos;\n                    break;\n                }\n            }\n        }\n\n        if (this.headersParsed) {\n            this.headerChunks.push(data.slice(0, headerPos));\n            this.rawHeaders = Buffer.concat(this.headerChunks, this.headerBytes);\n            this.headerChunks = null;\n            this.emit('headers', this.parseHeaders());\n            if (data.length - 1 > headerPos) {\n                let chunk = data.slice(headerPos);\n                this.bodySize += chunk.length;\n                // this would be the first chunk of data sent downstream\n                setImmediate(() => this.push(chunk));\n            }\n            return false;\n        } else {\n            this.headerBytes += data.length;\n            this.headerChunks.push(data);\n        }\n\n        // store last 4 bytes to catch header break\n        this.updateLastBytes(data);\n\n        return false;\n    }\n\n    _transform(chunk, encoding, callback) {\n        if (!chunk || !chunk.length) {\n            return callback();\n        }\n\n        if (typeof chunk === 'string') {\n            chunk = Buffer.from(chunk, encoding);\n        }\n\n        let headersFound;\n\n        try {\n            headersFound = this.checkHeaders(chunk);\n        } catch (E) {\n            return callback(E);\n        }\n\n        if (headersFound) {\n            this.bodySize += chunk.length;\n            this.push(chunk);\n        }\n\n        setImmediate(callback);\n    }\n\n    _flush(callback) {\n        if (this.headerChunks) {\n            let chunk = Buffer.concat(this.headerChunks, this.headerBytes);\n            this.bodySize += chunk.length;\n            this.push(chunk);\n            this.headerChunks = null;\n        }\n        callback();\n    }\n\n    parseHeaders() {\n        let lines = (this.rawHeaders || '').toString().split(/\\r?\\n/);\n        for (let i = lines.length - 1; i > 0; i--) {\n            if (/^\\s/.test(lines[i])) {\n                lines[i - 1] += '\\n' + lines[i];\n                lines.splice(i, 1);\n            }\n        }\n        return lines\n            .filter(line => line.trim())\n            .map(line => ({\n                key: line.substr(0, line.indexOf(':')).trim().toLowerCase(),\n                line\n            }));\n    }\n}\n\nmodule.exports = MessageParser;\n"]},"metadata":{},"sourceType":"script"}