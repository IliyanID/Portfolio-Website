{"ast":null,"code":"/* eslint no-console: 0 */\n'use strict';\n\nconst urllib = require('url');\n\nconst util = require('util');\n\nconst fs = require('fs');\n\nconst fetch = require('../fetch');\n\nconst dns = require('dns');\n\nconst net = require('net');\n\nconst DNS_TTL = 5 * 60 * 1000;\n\nconst resolver = (family, hostname, callback) => {\n  dns['resolve' + family](hostname, (err, addresses) => {\n    if (err) {\n      switch (err.code) {\n        case dns.NODATA:\n        case dns.NOTFOUND:\n        case dns.NOTIMP:\n        case dns.SERVFAIL:\n        case dns.CONNREFUSED:\n        case 'EAI_AGAIN':\n          return callback(null, []);\n      }\n\n      return callback(err);\n    }\n\n    return callback(null, Array.isArray(addresses) ? addresses : [].concat(addresses || []));\n  });\n};\n\nconst dnsCache = module.exports.dnsCache = new Map();\n\nmodule.exports.resolveHostname = (options, callback) => {\n  options = options || {};\n\n  if (!options.host || net.isIP(options.host)) {\n    // nothing to do here\n    let value = {\n      host: options.host,\n      servername: options.servername || false\n    };\n    return callback(null, value);\n  }\n\n  let cached;\n\n  if (dnsCache.has(options.host)) {\n    cached = dnsCache.get(options.host);\n\n    if (!cached.expires || cached.expires >= Date.now()) {\n      return callback(null, {\n        host: cached.value.host,\n        servername: cached.value.servername,\n        _cached: true\n      });\n    }\n  }\n\n  resolver(4, options.host, (err, addresses) => {\n    if (err) {\n      if (cached) {\n        // ignore error, use expired value\n        return callback(null, cached.value);\n      }\n\n      return callback(err);\n    }\n\n    if (addresses && addresses.length) {\n      let value = {\n        host: addresses[0] || options.host,\n        servername: options.servername || options.host\n      };\n      dnsCache.set(options.host, {\n        value,\n        expires: Date.now() + DNS_TTL\n      });\n      return callback(null, value);\n    }\n\n    resolver(6, options.host, (err, addresses) => {\n      if (err) {\n        if (cached) {\n          // ignore error, use expired value\n          return callback(null, cached.value);\n        }\n\n        return callback(err);\n      }\n\n      if (addresses && addresses.length) {\n        let value = {\n          host: addresses[0] || options.host,\n          servername: options.servername || options.host\n        };\n        dnsCache.set(options.host, {\n          value,\n          expires: Date.now() + DNS_TTL\n        });\n        return callback(null, value);\n      }\n\n      try {\n        dns.lookup(options.host, {}, (err, address) => {\n          if (err) {\n            if (cached) {\n              // ignore error, use expired value\n              return callback(null, cached.value);\n            }\n\n            return callback(err);\n          }\n\n          if (!address && cached) {\n            // nothing was found, fallback to cached value\n            return callback(null, cached.value);\n          }\n\n          let value = {\n            host: address || options.host,\n            servername: options.servername || options.host\n          };\n          dnsCache.set(options.host, {\n            value,\n            expires: Date.now() + DNS_TTL\n          });\n          return callback(null, value);\n        });\n      } catch (err) {\n        if (cached) {\n          // ignore error, use expired value\n          return callback(null, cached.value);\n        }\n\n        return callback(err);\n      }\n    });\n  });\n};\n/**\n * Parses connection url to a structured configuration object\n *\n * @param {String} str Connection url\n * @return {Object} Configuration object\n */\n\n\nmodule.exports.parseConnectionUrl = str => {\n  str = str || '';\n  let options = {};\n  [urllib.parse(str, true)].forEach(url => {\n    let auth;\n\n    switch (url.protocol) {\n      case 'smtp:':\n        options.secure = false;\n        break;\n\n      case 'smtps:':\n        options.secure = true;\n        break;\n\n      case 'direct:':\n        options.direct = true;\n        break;\n    }\n\n    if (!isNaN(url.port) && Number(url.port)) {\n      options.port = Number(url.port);\n    }\n\n    if (url.hostname) {\n      options.host = url.hostname;\n    }\n\n    if (url.auth) {\n      auth = url.auth.split(':');\n\n      if (!options.auth) {\n        options.auth = {};\n      }\n\n      options.auth.user = auth.shift();\n      options.auth.pass = auth.join(':');\n    }\n\n    Object.keys(url.query || {}).forEach(key => {\n      let obj = options;\n      let lKey = key;\n      let value = url.query[key];\n\n      if (!isNaN(value)) {\n        value = Number(value);\n      }\n\n      switch (value) {\n        case 'true':\n          value = true;\n          break;\n\n        case 'false':\n          value = false;\n          break;\n      } // tls is nested object\n\n\n      if (key.indexOf('tls.') === 0) {\n        lKey = key.substr(4);\n\n        if (!options.tls) {\n          options.tls = {};\n        }\n\n        obj = options.tls;\n      } else if (key.indexOf('.') >= 0) {\n        // ignore nested properties besides tls\n        return;\n      }\n\n      if (!(lKey in obj)) {\n        obj[lKey] = value;\n      }\n    });\n  });\n  return options;\n};\n\nmodule.exports._logFunc = (logger, level, defaults, data, message, ...args) => {\n  let entry = {};\n  Object.keys(defaults || {}).forEach(key => {\n    if (key !== 'level') {\n      entry[key] = defaults[key];\n    }\n  });\n  Object.keys(data || {}).forEach(key => {\n    if (key !== 'level') {\n      entry[key] = data[key];\n    }\n  });\n  logger[level](entry, message, ...args);\n};\n/**\n * Returns a bunyan-compatible logger interface. Uses either provided logger or\n * creates a default console logger\n *\n * @param {Object} [options] Options object that might include 'logger' value\n * @return {Object} bunyan compatible logger\n */\n\n\nmodule.exports.getLogger = (options, defaults) => {\n  options = options || {};\n  let response = {};\n  let levels = ['trace', 'debug', 'info', 'warn', 'error', 'fatal'];\n\n  if (!options.logger) {\n    // use vanity logger\n    levels.forEach(level => {\n      response[level] = () => false;\n    });\n    return response;\n  }\n\n  let logger = options.logger;\n\n  if (options.logger === true) {\n    // create console logger\n    logger = createDefaultLogger(levels);\n  }\n\n  levels.forEach(level => {\n    response[level] = (data, message, ...args) => {\n      module.exports._logFunc(logger, level, defaults, data, message, ...args);\n    };\n  });\n  return response;\n};\n/**\n * Wrapper for creating a callback that either resolves or rejects a promise\n * based on input\n *\n * @param {Function} resolve Function to run if callback is called\n * @param {Function} reject Function to run if callback ends with an error\n */\n\n\nmodule.exports.callbackPromise = (resolve, reject) => function () {\n  let args = Array.from(arguments);\n  let err = args.shift();\n\n  if (err) {\n    reject(err);\n  } else {\n    resolve(...args);\n  }\n};\n/**\n * Resolves a String or a Buffer value for content value. Useful if the value\n * is a Stream or a file or an URL. If the value is a Stream, overwrites\n * the stream object with the resolved value (you can't stream a value twice).\n *\n * This is useful when you want to create a plugin that needs a content value,\n * for example the `html` or `text` value as a String or a Buffer but not as\n * a file path or an URL.\n *\n * @param {Object} data An object or an Array you want to resolve an element for\n * @param {String|Number} key Property name or an Array index\n * @param {Function} callback Callback function with (err, value)\n */\n\n\nmodule.exports.resolveContent = (data, key, callback) => {\n  let promise;\n\n  if (!callback) {\n    promise = new Promise((resolve, reject) => {\n      callback = module.exports.callbackPromise(resolve, reject);\n    });\n  }\n\n  let content = data && data[key] && data[key].content || data[key];\n  let contentStream;\n  let encoding = (typeof data[key] === 'object' && data[key].encoding || 'utf8').toString().toLowerCase().replace(/[-_\\s]/g, '');\n\n  if (!content) {\n    return callback(null, content);\n  }\n\n  if (typeof content === 'object') {\n    if (typeof content.pipe === 'function') {\n      return resolveStream(content, (err, value) => {\n        if (err) {\n          return callback(err);\n        } // we can't stream twice the same content, so we need\n        // to replace the stream object with the streaming result\n\n\n        data[key] = value;\n        callback(null, value);\n      });\n    } else if (/^https?:\\/\\//i.test(content.path || content.href)) {\n      contentStream = fetch(content.path || content.href);\n      return resolveStream(contentStream, callback);\n    } else if (/^data:/i.test(content.path || content.href)) {\n      let parts = (content.path || content.href).match(/^data:((?:[^;]*;)*(?:[^,]*)),(.*)$/i);\n\n      if (!parts) {\n        return callback(null, Buffer.from(0));\n      }\n\n      return callback(null, /\\bbase64$/i.test(parts[1]) ? Buffer.from(parts[2], 'base64') : Buffer.from(decodeURIComponent(parts[2])));\n    } else if (content.path) {\n      return resolveStream(fs.createReadStream(content.path), callback);\n    }\n  }\n\n  if (typeof data[key].content === 'string' && !['utf8', 'usascii', 'ascii'].includes(encoding)) {\n    content = Buffer.from(data[key].content, encoding);\n  } // default action, return as is\n\n\n  setImmediate(() => callback(null, content));\n  return promise;\n};\n/**\n * Copies properties from source objects to target objects\n */\n\n\nmodule.exports.assign = function ()\n/* target, ... sources */\n{\n  let args = Array.from(arguments);\n  let target = args.shift() || {};\n  args.forEach(source => {\n    Object.keys(source || {}).forEach(key => {\n      if (['tls', 'auth'].includes(key) && source[key] && typeof source[key] === 'object') {\n        // tls and auth are special keys that need to be enumerated separately\n        // other objects are passed as is\n        if (!target[key]) {\n          // ensure that target has this key\n          target[key] = {};\n        }\n\n        Object.keys(source[key]).forEach(subKey => {\n          target[key][subKey] = source[key][subKey];\n        });\n      } else {\n        target[key] = source[key];\n      }\n    });\n  });\n  return target;\n};\n\nmodule.exports.encodeXText = str => {\n  // ! 0x21\n  // + 0x2B\n  // = 0x3D\n  // ~ 0x7E\n  if (!/[^\\x21-\\x2A\\x2C-\\x3C\\x3E-\\x7E]/.test(str)) {\n    return str;\n  }\n\n  let buf = Buffer.from(str);\n  let result = '';\n\n  for (let i = 0, len = buf.length; i < len; i++) {\n    let c = buf[i];\n\n    if (c < 0x21 || c > 0x7e || c === 0x2b || c === 0x3d) {\n      result += '+' + (c < 0x10 ? '0' : '') + c.toString(16).toUpperCase();\n    } else {\n      result += String.fromCharCode(c);\n    }\n  }\n\n  return result;\n};\n/**\n * Streams a stream value into a Buffer\n *\n * @param {Object} stream Readable stream\n * @param {Function} callback Callback function with (err, value)\n */\n\n\nfunction resolveStream(stream, callback) {\n  let responded = false;\n  let chunks = [];\n  let chunklen = 0;\n  stream.on('error', err => {\n    if (responded) {\n      return;\n    }\n\n    responded = true;\n    callback(err);\n  });\n  stream.on('readable', () => {\n    let chunk;\n\n    while ((chunk = stream.read()) !== null) {\n      chunks.push(chunk);\n      chunklen += chunk.length;\n    }\n  });\n  stream.on('end', () => {\n    if (responded) {\n      return;\n    }\n\n    responded = true;\n    let value;\n\n    try {\n      value = Buffer.concat(chunks, chunklen);\n    } catch (E) {\n      return callback(E);\n    }\n\n    callback(null, value);\n  });\n}\n/**\n * Generates a bunyan-like logger that prints to console\n *\n * @returns {Object} Bunyan logger instance\n */\n\n\nfunction createDefaultLogger(levels) {\n  let levelMaxLen = 0;\n  let levelNames = new Map();\n  levels.forEach(level => {\n    if (level.length > levelMaxLen) {\n      levelMaxLen = level.length;\n    }\n  });\n  levels.forEach(level => {\n    let levelName = level.toUpperCase();\n\n    if (levelName.length < levelMaxLen) {\n      levelName += ' '.repeat(levelMaxLen - levelName.length);\n    }\n\n    levelNames.set(level, levelName);\n  });\n\n  let print = (level, entry, message, ...args) => {\n    let prefix = '';\n\n    if (entry) {\n      if (entry.tnx === 'server') {\n        prefix = 'S: ';\n      } else if (entry.tnx === 'client') {\n        prefix = 'C: ';\n      }\n\n      if (entry.sid) {\n        prefix = '[' + entry.sid + '] ' + prefix;\n      }\n\n      if (entry.cid) {\n        prefix = '[#' + entry.cid + '] ' + prefix;\n      }\n    }\n\n    message = util.format(message, ...args);\n    message.split(/\\r?\\n/).forEach(line => {\n      console.log('[%s] %s %s', new Date().toISOString().substr(0, 19).replace(/T/, ' '), levelNames.get(level), prefix + line);\n    });\n  };\n\n  let logger = {};\n  levels.forEach(level => {\n    logger[level] = print.bind(null, level);\n  });\n  return logger;\n}","map":{"version":3,"sources":["C:/Users/Iliyan/Documents/GitHub/Portfolio-Website/Front-End/node_modules/nodemailer/lib/shared/index.js"],"names":["urllib","require","util","fs","fetch","dns","net","DNS_TTL","resolver","family","hostname","callback","err","addresses","code","NODATA","NOTFOUND","NOTIMP","SERVFAIL","CONNREFUSED","Array","isArray","concat","dnsCache","module","exports","Map","resolveHostname","options","host","isIP","value","servername","cached","has","get","expires","Date","now","_cached","length","set","lookup","address","parseConnectionUrl","str","parse","forEach","url","auth","protocol","secure","direct","isNaN","port","Number","split","user","shift","pass","join","Object","keys","query","key","obj","lKey","indexOf","substr","tls","_logFunc","logger","level","defaults","data","message","args","entry","getLogger","response","levels","createDefaultLogger","callbackPromise","resolve","reject","from","arguments","resolveContent","promise","Promise","content","contentStream","encoding","toString","toLowerCase","replace","pipe","resolveStream","test","path","href","parts","match","Buffer","decodeURIComponent","createReadStream","includes","setImmediate","assign","target","source","subKey","encodeXText","buf","result","i","len","c","toUpperCase","String","fromCharCode","stream","responded","chunks","chunklen","on","chunk","read","push","E","levelMaxLen","levelNames","levelName","repeat","print","prefix","tnx","sid","cid","format","line","console","log","toISOString","bind"],"mappings":"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","sourcesContent":["/* eslint no-console: 0 */\n\n'use strict';\n\nconst urllib = require('url');\nconst util = require('util');\nconst fs = require('fs');\nconst fetch = require('../fetch');\nconst dns = require('dns');\nconst net = require('net');\n\nconst DNS_TTL = 5 * 60 * 1000;\n\nconst resolver = (family, hostname, callback) => {\n    dns['resolve' + family](hostname, (err, addresses) => {\n        if (err) {\n            switch (err.code) {\n                case dns.NODATA:\n                case dns.NOTFOUND:\n                case dns.NOTIMP:\n                case dns.SERVFAIL:\n                case dns.CONNREFUSED:\n                case 'EAI_AGAIN':\n                    return callback(null, []);\n            }\n            return callback(err);\n        }\n        return callback(null, Array.isArray(addresses) ? addresses : [].concat(addresses || []));\n    });\n};\n\nconst dnsCache = (module.exports.dnsCache = new Map());\nmodule.exports.resolveHostname = (options, callback) => {\n    options = options || {};\n\n    if (!options.host || net.isIP(options.host)) {\n        // nothing to do here\n        let value = {\n            host: options.host,\n            servername: options.servername || false\n        };\n        return callback(null, value);\n    }\n\n    let cached;\n\n    if (dnsCache.has(options.host)) {\n        cached = dnsCache.get(options.host);\n        if (!cached.expires || cached.expires >= Date.now()) {\n            return callback(null, {\n                host: cached.value.host,\n                servername: cached.value.servername,\n                _cached: true\n            });\n        }\n    }\n\n    resolver(4, options.host, (err, addresses) => {\n        if (err) {\n            if (cached) {\n                // ignore error, use expired value\n                return callback(null, cached.value);\n            }\n            return callback(err);\n        }\n        if (addresses && addresses.length) {\n            let value = {\n                host: addresses[0] || options.host,\n                servername: options.servername || options.host\n            };\n            dnsCache.set(options.host, {\n                value,\n                expires: Date.now() + DNS_TTL\n            });\n            return callback(null, value);\n        }\n\n        resolver(6, options.host, (err, addresses) => {\n            if (err) {\n                if (cached) {\n                    // ignore error, use expired value\n                    return callback(null, cached.value);\n                }\n                return callback(err);\n            }\n            if (addresses && addresses.length) {\n                let value = {\n                    host: addresses[0] || options.host,\n                    servername: options.servername || options.host\n                };\n                dnsCache.set(options.host, {\n                    value,\n                    expires: Date.now() + DNS_TTL\n                });\n                return callback(null, value);\n            }\n\n            try {\n                dns.lookup(options.host, {}, (err, address) => {\n                    if (err) {\n                        if (cached) {\n                            // ignore error, use expired value\n                            return callback(null, cached.value);\n                        }\n                        return callback(err);\n                    }\n\n                    if (!address && cached) {\n                        // nothing was found, fallback to cached value\n                        return callback(null, cached.value);\n                    }\n\n                    let value = {\n                        host: address || options.host,\n                        servername: options.servername || options.host\n                    };\n                    dnsCache.set(options.host, {\n                        value,\n                        expires: Date.now() + DNS_TTL\n                    });\n                    return callback(null, value);\n                });\n            } catch (err) {\n                if (cached) {\n                    // ignore error, use expired value\n                    return callback(null, cached.value);\n                }\n                return callback(err);\n            }\n        });\n    });\n};\n/**\n * Parses connection url to a structured configuration object\n *\n * @param {String} str Connection url\n * @return {Object} Configuration object\n */\nmodule.exports.parseConnectionUrl = str => {\n    str = str || '';\n    let options = {};\n\n    [urllib.parse(str, true)].forEach(url => {\n        let auth;\n\n        switch (url.protocol) {\n            case 'smtp:':\n                options.secure = false;\n                break;\n            case 'smtps:':\n                options.secure = true;\n                break;\n            case 'direct:':\n                options.direct = true;\n                break;\n        }\n\n        if (!isNaN(url.port) && Number(url.port)) {\n            options.port = Number(url.port);\n        }\n\n        if (url.hostname) {\n            options.host = url.hostname;\n        }\n\n        if (url.auth) {\n            auth = url.auth.split(':');\n\n            if (!options.auth) {\n                options.auth = {};\n            }\n\n            options.auth.user = auth.shift();\n            options.auth.pass = auth.join(':');\n        }\n\n        Object.keys(url.query || {}).forEach(key => {\n            let obj = options;\n            let lKey = key;\n            let value = url.query[key];\n\n            if (!isNaN(value)) {\n                value = Number(value);\n            }\n\n            switch (value) {\n                case 'true':\n                    value = true;\n                    break;\n                case 'false':\n                    value = false;\n                    break;\n            }\n\n            // tls is nested object\n            if (key.indexOf('tls.') === 0) {\n                lKey = key.substr(4);\n                if (!options.tls) {\n                    options.tls = {};\n                }\n                obj = options.tls;\n            } else if (key.indexOf('.') >= 0) {\n                // ignore nested properties besides tls\n                return;\n            }\n\n            if (!(lKey in obj)) {\n                obj[lKey] = value;\n            }\n        });\n    });\n\n    return options;\n};\n\nmodule.exports._logFunc = (logger, level, defaults, data, message, ...args) => {\n    let entry = {};\n\n    Object.keys(defaults || {}).forEach(key => {\n        if (key !== 'level') {\n            entry[key] = defaults[key];\n        }\n    });\n\n    Object.keys(data || {}).forEach(key => {\n        if (key !== 'level') {\n            entry[key] = data[key];\n        }\n    });\n\n    logger[level](entry, message, ...args);\n};\n\n/**\n * Returns a bunyan-compatible logger interface. Uses either provided logger or\n * creates a default console logger\n *\n * @param {Object} [options] Options object that might include 'logger' value\n * @return {Object} bunyan compatible logger\n */\nmodule.exports.getLogger = (options, defaults) => {\n    options = options || {};\n\n    let response = {};\n    let levels = ['trace', 'debug', 'info', 'warn', 'error', 'fatal'];\n\n    if (!options.logger) {\n        // use vanity logger\n        levels.forEach(level => {\n            response[level] = () => false;\n        });\n        return response;\n    }\n\n    let logger = options.logger;\n\n    if (options.logger === true) {\n        // create console logger\n        logger = createDefaultLogger(levels);\n    }\n\n    levels.forEach(level => {\n        response[level] = (data, message, ...args) => {\n            module.exports._logFunc(logger, level, defaults, data, message, ...args);\n        };\n    });\n\n    return response;\n};\n\n/**\n * Wrapper for creating a callback that either resolves or rejects a promise\n * based on input\n *\n * @param {Function} resolve Function to run if callback is called\n * @param {Function} reject Function to run if callback ends with an error\n */\nmodule.exports.callbackPromise = (resolve, reject) =>\n    function () {\n        let args = Array.from(arguments);\n        let err = args.shift();\n        if (err) {\n            reject(err);\n        } else {\n            resolve(...args);\n        }\n    };\n\n/**\n * Resolves a String or a Buffer value for content value. Useful if the value\n * is a Stream or a file or an URL. If the value is a Stream, overwrites\n * the stream object with the resolved value (you can't stream a value twice).\n *\n * This is useful when you want to create a plugin that needs a content value,\n * for example the `html` or `text` value as a String or a Buffer but not as\n * a file path or an URL.\n *\n * @param {Object} data An object or an Array you want to resolve an element for\n * @param {String|Number} key Property name or an Array index\n * @param {Function} callback Callback function with (err, value)\n */\nmodule.exports.resolveContent = (data, key, callback) => {\n    let promise;\n\n    if (!callback) {\n        promise = new Promise((resolve, reject) => {\n            callback = module.exports.callbackPromise(resolve, reject);\n        });\n    }\n\n    let content = (data && data[key] && data[key].content) || data[key];\n    let contentStream;\n    let encoding = ((typeof data[key] === 'object' && data[key].encoding) || 'utf8')\n        .toString()\n        .toLowerCase()\n        .replace(/[-_\\s]/g, '');\n\n    if (!content) {\n        return callback(null, content);\n    }\n\n    if (typeof content === 'object') {\n        if (typeof content.pipe === 'function') {\n            return resolveStream(content, (err, value) => {\n                if (err) {\n                    return callback(err);\n                }\n                // we can't stream twice the same content, so we need\n                // to replace the stream object with the streaming result\n                data[key] = value;\n                callback(null, value);\n            });\n        } else if (/^https?:\\/\\//i.test(content.path || content.href)) {\n            contentStream = fetch(content.path || content.href);\n            return resolveStream(contentStream, callback);\n        } else if (/^data:/i.test(content.path || content.href)) {\n            let parts = (content.path || content.href).match(/^data:((?:[^;]*;)*(?:[^,]*)),(.*)$/i);\n            if (!parts) {\n                return callback(null, Buffer.from(0));\n            }\n            return callback(null, /\\bbase64$/i.test(parts[1]) ? Buffer.from(parts[2], 'base64') : Buffer.from(decodeURIComponent(parts[2])));\n        } else if (content.path) {\n            return resolveStream(fs.createReadStream(content.path), callback);\n        }\n    }\n\n    if (typeof data[key].content === 'string' && !['utf8', 'usascii', 'ascii'].includes(encoding)) {\n        content = Buffer.from(data[key].content, encoding);\n    }\n\n    // default action, return as is\n    setImmediate(() => callback(null, content));\n\n    return promise;\n};\n\n/**\n * Copies properties from source objects to target objects\n */\nmodule.exports.assign = function (/* target, ... sources */) {\n    let args = Array.from(arguments);\n    let target = args.shift() || {};\n\n    args.forEach(source => {\n        Object.keys(source || {}).forEach(key => {\n            if (['tls', 'auth'].includes(key) && source[key] && typeof source[key] === 'object') {\n                // tls and auth are special keys that need to be enumerated separately\n                // other objects are passed as is\n                if (!target[key]) {\n                    // ensure that target has this key\n                    target[key] = {};\n                }\n                Object.keys(source[key]).forEach(subKey => {\n                    target[key][subKey] = source[key][subKey];\n                });\n            } else {\n                target[key] = source[key];\n            }\n        });\n    });\n    return target;\n};\n\nmodule.exports.encodeXText = str => {\n    // ! 0x21\n    // + 0x2B\n    // = 0x3D\n    // ~ 0x7E\n    if (!/[^\\x21-\\x2A\\x2C-\\x3C\\x3E-\\x7E]/.test(str)) {\n        return str;\n    }\n    let buf = Buffer.from(str);\n    let result = '';\n    for (let i = 0, len = buf.length; i < len; i++) {\n        let c = buf[i];\n        if (c < 0x21 || c > 0x7e || c === 0x2b || c === 0x3d) {\n            result += '+' + (c < 0x10 ? '0' : '') + c.toString(16).toUpperCase();\n        } else {\n            result += String.fromCharCode(c);\n        }\n    }\n    return result;\n};\n\n/**\n * Streams a stream value into a Buffer\n *\n * @param {Object} stream Readable stream\n * @param {Function} callback Callback function with (err, value)\n */\nfunction resolveStream(stream, callback) {\n    let responded = false;\n    let chunks = [];\n    let chunklen = 0;\n\n    stream.on('error', err => {\n        if (responded) {\n            return;\n        }\n\n        responded = true;\n        callback(err);\n    });\n\n    stream.on('readable', () => {\n        let chunk;\n        while ((chunk = stream.read()) !== null) {\n            chunks.push(chunk);\n            chunklen += chunk.length;\n        }\n    });\n\n    stream.on('end', () => {\n        if (responded) {\n            return;\n        }\n        responded = true;\n\n        let value;\n\n        try {\n            value = Buffer.concat(chunks, chunklen);\n        } catch (E) {\n            return callback(E);\n        }\n        callback(null, value);\n    });\n}\n\n/**\n * Generates a bunyan-like logger that prints to console\n *\n * @returns {Object} Bunyan logger instance\n */\nfunction createDefaultLogger(levels) {\n    let levelMaxLen = 0;\n    let levelNames = new Map();\n    levels.forEach(level => {\n        if (level.length > levelMaxLen) {\n            levelMaxLen = level.length;\n        }\n    });\n\n    levels.forEach(level => {\n        let levelName = level.toUpperCase();\n        if (levelName.length < levelMaxLen) {\n            levelName += ' '.repeat(levelMaxLen - levelName.length);\n        }\n        levelNames.set(level, levelName);\n    });\n\n    let print = (level, entry, message, ...args) => {\n        let prefix = '';\n        if (entry) {\n            if (entry.tnx === 'server') {\n                prefix = 'S: ';\n            } else if (entry.tnx === 'client') {\n                prefix = 'C: ';\n            }\n\n            if (entry.sid) {\n                prefix = '[' + entry.sid + '] ' + prefix;\n            }\n\n            if (entry.cid) {\n                prefix = '[#' + entry.cid + '] ' + prefix;\n            }\n        }\n\n        message = util.format(message, ...args);\n        message.split(/\\r?\\n/).forEach(line => {\n            console.log('[%s] %s %s', new Date().toISOString().substr(0, 19).replace(/T/, ' '), levelNames.get(level), prefix + line);\n        });\n    };\n\n    let logger = {};\n    levels.forEach(level => {\n        logger[level] = print.bind(null, level);\n    });\n\n    return logger;\n}\n"]},"metadata":{},"sourceType":"script"}