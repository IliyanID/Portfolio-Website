{"ast":null,"code":"/* eslint no-undefined: 0, prefer-spread: 0, no-control-regex: 0 */\n'use strict';\n\nconst crypto = require('crypto');\n\nconst os = require('os');\n\nconst fs = require('fs');\n\nconst punycode = require('punycode');\n\nconst PassThrough = require('stream').PassThrough;\n\nconst shared = require('../shared');\n\nconst mimeFuncs = require('../mime-funcs');\n\nconst qp = require('../qp');\n\nconst base64 = require('../base64');\n\nconst addressparser = require('../addressparser');\n\nconst fetch = require('../fetch');\n\nconst LastNewline = require('./last-newline');\n/**\n * Creates a new mime tree node. Assumes 'multipart/*' as the content type\n * if it is a branch, anything else counts as leaf. If rootNode is missing from\n * the options, assumes this is the root.\n *\n * @param {String} contentType Define the content type for the node. Can be left blank for attachments (derived from filename)\n * @param {Object} [options] optional options\n * @param {Object} [options.rootNode] root node for this tree\n * @param {Object} [options.parentNode] immediate parent for this node\n * @param {Object} [options.filename] filename for an attachment node\n * @param {String} [options.baseBoundary] shared part of the unique multipart boundary\n * @param {Boolean} [options.keepBcc] If true, do not exclude Bcc from the generated headers\n * @param {Function} [options.normalizeHeaderKey] method to normalize header keys for custom caseing\n * @param {String} [options.textEncoding] either 'Q' (the default) or 'B'\n */\n\n\nclass MimeNode {\n  constructor(contentType, options) {\n    this.nodeCounter = 0;\n    options = options || {};\n    /**\n     * shared part of the unique multipart boundary\n     */\n\n    this.baseBoundary = options.baseBoundary || crypto.randomBytes(8).toString('hex');\n    this.boundaryPrefix = options.boundaryPrefix || '--_NmP';\n    this.disableFileAccess = !!options.disableFileAccess;\n    this.disableUrlAccess = !!options.disableUrlAccess;\n    this.normalizeHeaderKey = options.normalizeHeaderKey;\n    /**\n     * If date headers is missing and current node is the root, this value is used instead\n     */\n\n    this.date = new Date();\n    /**\n     * Root node for current mime tree\n     */\n\n    this.rootNode = options.rootNode || this;\n    /**\n     * If true include Bcc in generated headers (if available)\n     */\n\n    this.keepBcc = !!options.keepBcc;\n    /**\n     * If filename is specified but contentType is not (probably an attachment)\n     * detect the content type from filename extension\n     */\n\n    if (options.filename) {\n      /**\n       * Filename for this node. Useful with attachments\n       */\n      this.filename = options.filename;\n\n      if (!contentType) {\n        contentType = mimeFuncs.detectMimeType(this.filename.split('.').pop());\n      }\n    }\n    /**\n     * Indicates which encoding should be used for header strings: \"Q\" or \"B\"\n     */\n\n\n    this.textEncoding = (options.textEncoding || '').toString().trim().charAt(0).toUpperCase();\n    /**\n     * Immediate parent for this node (or undefined if not set)\n     */\n\n    this.parentNode = options.parentNode;\n    /**\n     * Hostname for default message-id values\n     */\n\n    this.hostname = options.hostname;\n    /**\n     * An array for possible child nodes\n     */\n\n    this.childNodes = [];\n    /**\n     * Used for generating unique boundaries (prepended to the shared base)\n     */\n\n    this._nodeId = ++this.rootNode.nodeCounter;\n    /**\n     * A list of header values for this node in the form of [{key:'', value:''}]\n     */\n\n    this._headers = [];\n    /**\n     * True if the content only uses ASCII printable characters\n     * @type {Boolean}\n     */\n\n    this._isPlainText = false;\n    /**\n     * True if the content is plain text but has longer lines than allowed\n     * @type {Boolean}\n     */\n\n    this._hasLongLines = false;\n    /**\n     * If set, use instead this value for envelopes instead of generating one\n     * @type {Boolean}\n     */\n\n    this._envelope = false;\n    /**\n     * If set then use this value as the stream content instead of building it\n     * @type {String|Buffer|Stream}\n     */\n\n    this._raw = false;\n    /**\n     * Additional transform streams that the message will be piped before\n     * exposing by createReadStream\n     * @type {Array}\n     */\n\n    this._transforms = [];\n    /**\n     * Additional process functions that the message will be piped through before\n     * exposing by createReadStream. These functions are run after transforms\n     * @type {Array}\n     */\n\n    this._processFuncs = [];\n    /**\n     * If content type is set (or derived from the filename) add it to headers\n     */\n\n    if (contentType) {\n      this.setHeader('Content-Type', contentType);\n    }\n  } /////// PUBLIC METHODS\n\n  /**\n   * Creates and appends a child node.Arguments provided are passed to MimeNode constructor\n   *\n   * @param {String} [contentType] Optional content type\n   * @param {Object} [options] Optional options object\n   * @return {Object} Created node object\n   */\n\n\n  createChild(contentType, options) {\n    if (!options && typeof contentType === 'object') {\n      options = contentType;\n      contentType = undefined;\n    }\n\n    let node = new MimeNode(contentType, options);\n    this.appendChild(node);\n    return node;\n  }\n  /**\n   * Appends an existing node to the mime tree. Removes the node from an existing\n   * tree if needed\n   *\n   * @param {Object} childNode node to be appended\n   * @return {Object} Appended node object\n   */\n\n\n  appendChild(childNode) {\n    if (childNode.rootNode !== this.rootNode) {\n      childNode.rootNode = this.rootNode;\n      childNode._nodeId = ++this.rootNode.nodeCounter;\n    }\n\n    childNode.parentNode = this;\n    this.childNodes.push(childNode);\n    return childNode;\n  }\n  /**\n   * Replaces current node with another node\n   *\n   * @param {Object} node Replacement node\n   * @return {Object} Replacement node\n   */\n\n\n  replace(node) {\n    if (node === this) {\n      return this;\n    }\n\n    this.parentNode.childNodes.forEach((childNode, i) => {\n      if (childNode === this) {\n        node.rootNode = this.rootNode;\n        node.parentNode = this.parentNode;\n        node._nodeId = this._nodeId;\n        this.rootNode = this;\n        this.parentNode = undefined;\n        node.parentNode.childNodes[i] = node;\n      }\n    });\n    return node;\n  }\n  /**\n   * Removes current node from the mime tree\n   *\n   * @return {Object} removed node\n   */\n\n\n  remove() {\n    if (!this.parentNode) {\n      return this;\n    }\n\n    for (let i = this.parentNode.childNodes.length - 1; i >= 0; i--) {\n      if (this.parentNode.childNodes[i] === this) {\n        this.parentNode.childNodes.splice(i, 1);\n        this.parentNode = undefined;\n        this.rootNode = this;\n        return this;\n      }\n    }\n  }\n  /**\n   * Sets a header value. If the value for selected key exists, it is overwritten.\n   * You can set multiple values as well by using [{key:'', value:''}] or\n   * {key: 'value'} as the first argument.\n   *\n   * @param {String|Array|Object} key Header key or a list of key value pairs\n   * @param {String} value Header value\n   * @return {Object} current node\n   */\n\n\n  setHeader(key, value) {\n    let added = false,\n        headerValue; // Allow setting multiple headers at once\n\n    if (!value && key && typeof key === 'object') {\n      // allow {key:'content-type', value: 'text/plain'}\n      if (key.key && 'value' in key) {\n        this.setHeader(key.key, key.value);\n      } else if (Array.isArray(key)) {\n        // allow [{key:'content-type', value: 'text/plain'}]\n        key.forEach(i => {\n          this.setHeader(i.key, i.value);\n        });\n      } else {\n        // allow {'content-type': 'text/plain'}\n        Object.keys(key).forEach(i => {\n          this.setHeader(i, key[i]);\n        });\n      }\n\n      return this;\n    }\n\n    key = this._normalizeHeaderKey(key);\n    headerValue = {\n      key,\n      value\n    }; // Check if the value exists and overwrite\n\n    for (let i = 0, len = this._headers.length; i < len; i++) {\n      if (this._headers[i].key === key) {\n        if (!added) {\n          // replace the first match\n          this._headers[i] = headerValue;\n          added = true;\n        } else {\n          // remove following matches\n          this._headers.splice(i, 1);\n\n          i--;\n          len--;\n        }\n      }\n    } // match not found, append the value\n\n\n    if (!added) {\n      this._headers.push(headerValue);\n    }\n\n    return this;\n  }\n  /**\n   * Adds a header value. If the value for selected key exists, the value is appended\n   * as a new field and old one is not touched.\n   * You can set multiple values as well by using [{key:'', value:''}] or\n   * {key: 'value'} as the first argument.\n   *\n   * @param {String|Array|Object} key Header key or a list of key value pairs\n   * @param {String} value Header value\n   * @return {Object} current node\n   */\n\n\n  addHeader(key, value) {\n    // Allow setting multiple headers at once\n    if (!value && key && typeof key === 'object') {\n      // allow {key:'content-type', value: 'text/plain'}\n      if (key.key && key.value) {\n        this.addHeader(key.key, key.value);\n      } else if (Array.isArray(key)) {\n        // allow [{key:'content-type', value: 'text/plain'}]\n        key.forEach(i => {\n          this.addHeader(i.key, i.value);\n        });\n      } else {\n        // allow {'content-type': 'text/plain'}\n        Object.keys(key).forEach(i => {\n          this.addHeader(i, key[i]);\n        });\n      }\n\n      return this;\n    } else if (Array.isArray(value)) {\n      value.forEach(val => {\n        this.addHeader(key, val);\n      });\n      return this;\n    }\n\n    this._headers.push({\n      key: this._normalizeHeaderKey(key),\n      value\n    });\n\n    return this;\n  }\n  /**\n   * Retrieves the first mathcing value of a selected key\n   *\n   * @param {String} key Key to search for\n   * @retun {String} Value for the key\n   */\n\n\n  getHeader(key) {\n    key = this._normalizeHeaderKey(key);\n\n    for (let i = 0, len = this._headers.length; i < len; i++) {\n      if (this._headers[i].key === key) {\n        return this._headers[i].value;\n      }\n    }\n  }\n  /**\n   * Sets body content for current node. If the value is a string, charset is added automatically\n   * to Content-Type (if it is text/*). If the value is a Buffer, you need to specify\n   * the charset yourself\n   *\n   * @param (String|Buffer) content Body content\n   * @return {Object} current node\n   */\n\n\n  setContent(content) {\n    this.content = content;\n\n    if (typeof this.content.pipe === 'function') {\n      // pre-stream handler. might be triggered if a stream is set as content\n      // and 'error' fires before anything is done with this stream\n      this._contentErrorHandler = err => {\n        this.content.removeListener('error', this._contentErrorHandler);\n        this.content = err;\n      };\n\n      this.content.once('error', this._contentErrorHandler);\n    } else if (typeof this.content === 'string') {\n      this._isPlainText = mimeFuncs.isPlainText(this.content);\n\n      if (this._isPlainText && mimeFuncs.hasLongerLines(this.content, 76)) {\n        // If there are lines longer than 76 symbols/bytes do not use 7bit\n        this._hasLongLines = true;\n      }\n    }\n\n    return this;\n  }\n\n  build(callback) {\n    let promise;\n\n    if (!callback) {\n      promise = new Promise((resolve, reject) => {\n        callback = shared.callbackPromise(resolve, reject);\n      });\n    }\n\n    let stream = this.createReadStream();\n    let buf = [];\n    let buflen = 0;\n    let returned = false;\n    stream.on('readable', () => {\n      let chunk;\n\n      while ((chunk = stream.read()) !== null) {\n        buf.push(chunk);\n        buflen += chunk.length;\n      }\n    });\n    stream.once('error', err => {\n      if (returned) {\n        return;\n      }\n\n      returned = true;\n      return callback(err);\n    });\n    stream.once('end', chunk => {\n      if (returned) {\n        return;\n      }\n\n      returned = true;\n\n      if (chunk && chunk.length) {\n        buf.push(chunk);\n        buflen += chunk.length;\n      }\n\n      return callback(null, Buffer.concat(buf, buflen));\n    });\n    return promise;\n  }\n\n  getTransferEncoding() {\n    let transferEncoding = false;\n    let contentType = (this.getHeader('Content-Type') || '').toString().toLowerCase().trim();\n\n    if (this.content) {\n      transferEncoding = (this.getHeader('Content-Transfer-Encoding') || '').toString().toLowerCase().trim();\n\n      if (!transferEncoding || !['base64', 'quoted-printable'].includes(transferEncoding)) {\n        if (/^text\\//i.test(contentType)) {\n          // If there are no special symbols, no need to modify the text\n          if (this._isPlainText && !this._hasLongLines) {\n            transferEncoding = '7bit';\n          } else if (typeof this.content === 'string' || this.content instanceof Buffer) {\n            // detect preferred encoding for string value\n            transferEncoding = this._getTextEncoding(this.content) === 'Q' ? 'quoted-printable' : 'base64';\n          } else {\n            // we can not check content for a stream, so either use preferred encoding or fallback to QP\n            transferEncoding = this.transferEncoding === 'B' ? 'base64' : 'quoted-printable';\n          }\n        } else if (!/^(multipart|message)\\//i.test(contentType)) {\n          transferEncoding = transferEncoding || 'base64';\n        }\n      }\n    }\n\n    return transferEncoding;\n  }\n  /**\n   * Builds the header block for the mime node. Append \\r\\n\\r\\n before writing the content\n   *\n   * @returns {String} Headers\n   */\n\n\n  buildHeaders() {\n    let transferEncoding = this.getTransferEncoding();\n    let headers = [];\n\n    if (transferEncoding) {\n      this.setHeader('Content-Transfer-Encoding', transferEncoding);\n    }\n\n    if (this.filename && !this.getHeader('Content-Disposition')) {\n      this.setHeader('Content-Disposition', 'attachment');\n    } // Ensure mandatory header fields\n\n\n    if (this.rootNode === this) {\n      if (!this.getHeader('Date')) {\n        this.setHeader('Date', this.date.toUTCString().replace(/GMT/, '+0000'));\n      } // ensure that Message-Id is present\n\n\n      this.messageId();\n\n      if (!this.getHeader('MIME-Version')) {\n        this.setHeader('MIME-Version', '1.0');\n      }\n    }\n\n    this._headers.forEach(header => {\n      let key = header.key;\n      let value = header.value;\n      let structured;\n      let param;\n      let options = {};\n      let formattedHeaders = ['From', 'Sender', 'To', 'Cc', 'Bcc', 'Reply-To', 'Date', 'References'];\n\n      if (value && typeof value === 'object' && !formattedHeaders.includes(key)) {\n        Object.keys(value).forEach(key => {\n          if (key !== 'value') {\n            options[key] = value[key];\n          }\n        });\n        value = (value.value || '').toString();\n\n        if (!value.trim()) {\n          return;\n        }\n      }\n\n      if (options.prepared) {\n        // header value is\n        if (options.foldLines) {\n          headers.push(mimeFuncs.foldLines(key + ': ' + value));\n        } else {\n          headers.push(key + ': ' + value);\n        }\n\n        return;\n      }\n\n      switch (header.key) {\n        case 'Content-Disposition':\n          structured = mimeFuncs.parseHeaderValue(value);\n\n          if (this.filename) {\n            structured.params.filename = this.filename;\n          }\n\n          value = mimeFuncs.buildHeaderValue(structured);\n          break;\n\n        case 'Content-Type':\n          structured = mimeFuncs.parseHeaderValue(value);\n\n          this._handleContentType(structured);\n\n          if (structured.value.match(/^text\\/plain\\b/) && typeof this.content === 'string' && /[\\u0080-\\uFFFF]/.test(this.content)) {\n            structured.params.charset = 'utf-8';\n          }\n\n          value = mimeFuncs.buildHeaderValue(structured);\n\n          if (this.filename) {\n            // add support for non-compliant clients like QQ webmail\n            // we can't build the value with buildHeaderValue as the value is non standard and\n            // would be converted to parameter continuation encoding that we do not want\n            param = this._encodeWords(this.filename);\n\n            if (param !== this.filename || /[\\s'\"\\\\;:/=(),<>@[\\]?]|^-/.test(param)) {\n              // include value in quotes if needed\n              param = '\"' + param + '\"';\n            }\n\n            value += '; name=' + param;\n          }\n\n          break;\n\n        case 'Bcc':\n          if (!this.keepBcc) {\n            // skip BCC values\n            return;\n          }\n\n          break;\n      }\n\n      value = this._encodeHeaderValue(key, value); // skip empty lines\n\n      if (!(value || '').toString().trim()) {\n        return;\n      }\n\n      if (typeof this.normalizeHeaderKey === 'function') {\n        let normalized = this.normalizeHeaderKey(key, value);\n\n        if (normalized && typeof normalized === 'string' && normalized.length) {\n          key = normalized;\n        }\n      }\n\n      headers.push(mimeFuncs.foldLines(key + ': ' + value, 76));\n    });\n\n    return headers.join('\\r\\n');\n  }\n  /**\n   * Streams the rfc2822 message from the current node. If this is a root node,\n   * mandatory header fields are set if missing (Date, Message-Id, MIME-Version)\n   *\n   * @return {String} Compiled message\n   */\n\n\n  createReadStream(options) {\n    options = options || {};\n    let stream = new PassThrough(options);\n    let outputStream = stream;\n    let transform;\n    this.stream(stream, options, err => {\n      if (err) {\n        outputStream.emit('error', err);\n        return;\n      }\n\n      stream.end();\n    });\n\n    for (let i = 0, len = this._transforms.length; i < len; i++) {\n      transform = typeof this._transforms[i] === 'function' ? this._transforms[i]() : this._transforms[i];\n      outputStream.once('error', err => {\n        transform.emit('error', err);\n      });\n      outputStream = outputStream.pipe(transform);\n    } // ensure terminating newline after possible user transforms\n\n\n    transform = new LastNewline();\n    outputStream.once('error', err => {\n      transform.emit('error', err);\n    });\n    outputStream = outputStream.pipe(transform); // dkim and stuff\n\n    for (let i = 0, len = this._processFuncs.length; i < len; i++) {\n      transform = this._processFuncs[i];\n      outputStream = transform(outputStream);\n    }\n\n    return outputStream;\n  }\n  /**\n   * Appends a transform stream object to the transforms list. Final output\n   * is passed through this stream before exposing\n   *\n   * @param {Object} transform Read-Write stream\n   */\n\n\n  transform(transform) {\n    this._transforms.push(transform);\n  }\n  /**\n   * Appends a post process function. The functon is run after transforms and\n   * uses the following syntax\n   *\n   *   processFunc(input) -> outputStream\n   *\n   * @param {Object} processFunc Read-Write stream\n   */\n\n\n  processFunc(processFunc) {\n    this._processFuncs.push(processFunc);\n  }\n\n  stream(outputStream, options, done) {\n    let transferEncoding = this.getTransferEncoding();\n    let contentStream;\n    let localStream; // protect actual callback against multiple triggering\n\n    let returned = false;\n\n    let callback = err => {\n      if (returned) {\n        return;\n      }\n\n      returned = true;\n      done(err);\n    }; // for multipart nodes, push child nodes\n    // for content nodes end the stream\n\n\n    let finalize = () => {\n      let childId = 0;\n\n      let processChildNode = () => {\n        if (childId >= this.childNodes.length) {\n          outputStream.write('\\r\\n--' + this.boundary + '--\\r\\n');\n          return callback();\n        }\n\n        let child = this.childNodes[childId++];\n        outputStream.write((childId > 1 ? '\\r\\n' : '') + '--' + this.boundary + '\\r\\n');\n        child.stream(outputStream, options, err => {\n          if (err) {\n            return callback(err);\n          }\n\n          setImmediate(processChildNode);\n        });\n      };\n\n      if (this.multipart) {\n        setImmediate(processChildNode);\n      } else {\n        return callback();\n      }\n    }; // pushes node content\n\n\n    let sendContent = () => {\n      if (this.content) {\n        if (Object.prototype.toString.call(this.content) === '[object Error]') {\n          // content is already errored\n          return callback(this.content);\n        }\n\n        if (typeof this.content.pipe === 'function') {\n          this.content.removeListener('error', this._contentErrorHandler);\n\n          this._contentErrorHandler = err => callback(err);\n\n          this.content.once('error', this._contentErrorHandler);\n        }\n\n        let createStream = () => {\n          if (['quoted-printable', 'base64'].includes(transferEncoding)) {\n            contentStream = new (transferEncoding === 'base64' ? base64 : qp).Encoder(options);\n            contentStream.pipe(outputStream, {\n              end: false\n            });\n            contentStream.once('end', finalize);\n            contentStream.once('error', err => callback(err));\n            localStream = this._getStream(this.content);\n            localStream.pipe(contentStream);\n          } else {\n            // anything that is not QP or Base54 passes as-is\n            localStream = this._getStream(this.content);\n            localStream.pipe(outputStream, {\n              end: false\n            });\n            localStream.once('end', finalize);\n          }\n\n          localStream.once('error', err => callback(err));\n        };\n\n        if (this.content._resolve) {\n          let chunks = [];\n          let chunklen = 0;\n          let returned = false;\n\n          let sourceStream = this._getStream(this.content);\n\n          sourceStream.on('error', err => {\n            if (returned) {\n              return;\n            }\n\n            returned = true;\n            callback(err);\n          });\n          sourceStream.on('readable', () => {\n            let chunk;\n\n            while ((chunk = sourceStream.read()) !== null) {\n              chunks.push(chunk);\n              chunklen += chunk.length;\n            }\n          });\n          sourceStream.on('end', () => {\n            if (returned) {\n              return;\n            }\n\n            returned = true;\n            this.content._resolve = false;\n            this.content._resolvedValue = Buffer.concat(chunks, chunklen);\n            setImmediate(createStream);\n          });\n        } else {\n          setImmediate(createStream);\n        }\n\n        return;\n      } else {\n        return setImmediate(finalize);\n      }\n    };\n\n    if (this._raw) {\n      setImmediate(() => {\n        if (Object.prototype.toString.call(this._raw) === '[object Error]') {\n          // content is already errored\n          return callback(this._raw);\n        } // remove default error handler (if set)\n\n\n        if (typeof this._raw.pipe === 'function') {\n          this._raw.removeListener('error', this._contentErrorHandler);\n        }\n\n        let raw = this._getStream(this._raw);\n\n        raw.pipe(outputStream, {\n          end: false\n        });\n        raw.on('error', err => outputStream.emit('error', err));\n        raw.on('end', finalize);\n      });\n    } else {\n      outputStream.write(this.buildHeaders() + '\\r\\n\\r\\n');\n      setImmediate(sendContent);\n    }\n  }\n  /**\n   * Sets envelope to be used instead of the generated one\n   *\n   * @return {Object} SMTP envelope in the form of {from: 'from@example.com', to: ['to@example.com']}\n   */\n\n\n  setEnvelope(envelope) {\n    let list;\n    this._envelope = {\n      from: false,\n      to: []\n    };\n\n    if (envelope.from) {\n      list = [];\n\n      this._convertAddresses(this._parseAddresses(envelope.from), list);\n\n      list = list.filter(address => address && address.address);\n\n      if (list.length && list[0]) {\n        this._envelope.from = list[0].address;\n      }\n    }\n\n    ['to', 'cc', 'bcc'].forEach(key => {\n      if (envelope[key]) {\n        this._convertAddresses(this._parseAddresses(envelope[key]), this._envelope.to);\n      }\n    });\n    this._envelope.to = this._envelope.to.map(to => to.address).filter(address => address);\n    let standardFields = ['to', 'cc', 'bcc', 'from'];\n    Object.keys(envelope).forEach(key => {\n      if (!standardFields.includes(key)) {\n        this._envelope[key] = envelope[key];\n      }\n    });\n    return this;\n  }\n  /**\n   * Generates and returns an object with parsed address fields\n   *\n   * @return {Object} Address object\n   */\n\n\n  getAddresses() {\n    let addresses = {};\n\n    this._headers.forEach(header => {\n      let key = header.key.toLowerCase();\n\n      if (['from', 'sender', 'reply-to', 'to', 'cc', 'bcc'].includes(key)) {\n        if (!Array.isArray(addresses[key])) {\n          addresses[key] = [];\n        }\n\n        this._convertAddresses(this._parseAddresses(header.value), addresses[key]);\n      }\n    });\n\n    return addresses;\n  }\n  /**\n   * Generates and returns SMTP envelope with the sender address and a list of recipients addresses\n   *\n   * @return {Object} SMTP envelope in the form of {from: 'from@example.com', to: ['to@example.com']}\n   */\n\n\n  getEnvelope() {\n    if (this._envelope) {\n      return this._envelope;\n    }\n\n    let envelope = {\n      from: false,\n      to: []\n    };\n\n    this._headers.forEach(header => {\n      let list = [];\n\n      if (header.key === 'From' || !envelope.from && ['Reply-To', 'Sender'].includes(header.key)) {\n        this._convertAddresses(this._parseAddresses(header.value), list);\n\n        if (list.length && list[0]) {\n          envelope.from = list[0].address;\n        }\n      } else if (['To', 'Cc', 'Bcc'].includes(header.key)) {\n        this._convertAddresses(this._parseAddresses(header.value), envelope.to);\n      }\n    });\n\n    envelope.to = envelope.to.map(to => to.address);\n    return envelope;\n  }\n  /**\n   * Returns Message-Id value. If it does not exist, then creates one\n   *\n   * @return {String} Message-Id value\n   */\n\n\n  messageId() {\n    let messageId = this.getHeader('Message-ID'); // You really should define your own Message-Id field!\n\n    if (!messageId) {\n      messageId = this._generateMessageId();\n      this.setHeader('Message-ID', messageId);\n    }\n\n    return messageId;\n  }\n  /**\n   * Sets pregenerated content that will be used as the output of this node\n   *\n   * @param {String|Buffer|Stream} Raw MIME contents\n   */\n\n\n  setRaw(raw) {\n    this._raw = raw;\n\n    if (this._raw && typeof this._raw.pipe === 'function') {\n      // pre-stream handler. might be triggered if a stream is set as content\n      // and 'error' fires before anything is done with this stream\n      this._contentErrorHandler = err => {\n        this._raw.removeListener('error', this._contentErrorHandler);\n\n        this._raw = err;\n      };\n\n      this._raw.once('error', this._contentErrorHandler);\n    }\n\n    return this;\n  } /////// PRIVATE METHODS\n\n  /**\n   * Detects and returns handle to a stream related with the content.\n   *\n   * @param {Mixed} content Node content\n   * @returns {Object} Stream object\n   */\n\n\n  _getStream(content) {\n    let contentStream;\n\n    if (content._resolvedValue) {\n      // pass string or buffer content as a stream\n      contentStream = new PassThrough();\n      setImmediate(() => contentStream.end(content._resolvedValue));\n      return contentStream;\n    } else if (typeof content.pipe === 'function') {\n      // assume as stream\n      return content;\n    } else if (content && typeof content.path === 'string' && !content.href) {\n      if (this.disableFileAccess) {\n        contentStream = new PassThrough();\n        setImmediate(() => contentStream.emit('error', new Error('File access rejected for ' + content.path)));\n        return contentStream;\n      } // read file\n\n\n      return fs.createReadStream(content.path);\n    } else if (content && typeof content.href === 'string') {\n      if (this.disableUrlAccess) {\n        contentStream = new PassThrough();\n        setImmediate(() => contentStream.emit('error', new Error('Url access rejected for ' + content.href)));\n        return contentStream;\n      } // fetch URL\n\n\n      return fetch(content.href, {\n        headers: content.httpHeaders\n      });\n    } else {\n      // pass string or buffer content as a stream\n      contentStream = new PassThrough();\n      setImmediate(() => contentStream.end(content || ''));\n      return contentStream;\n    }\n  }\n  /**\n   * Parses addresses. Takes in a single address or an array or an\n   * array of address arrays (eg. To: [[first group], [second group],...])\n   *\n   * @param {Mixed} addresses Addresses to be parsed\n   * @return {Array} An array of address objects\n   */\n\n\n  _parseAddresses(addresses) {\n    return [].concat.apply([], [].concat(addresses).map(address => {\n      // eslint-disable-line prefer-spread\n      if (address && address.address) {\n        address.address = this._normalizeAddress(address.address);\n        address.name = address.name || '';\n        return [address];\n      }\n\n      return addressparser(address);\n    }));\n  }\n  /**\n   * Normalizes a header key, uses Camel-Case form, except for uppercase MIME-\n   *\n   * @param {String} key Key to be normalized\n   * @return {String} key in Camel-Case form\n   */\n\n\n  _normalizeHeaderKey(key) {\n    key = (key || '').toString() // no newlines in keys\n    .replace(/\\r?\\n|\\r/g, ' ').trim().toLowerCase() // use uppercase words, except MIME\n    .replace(/^X-SMTPAPI$|^(MIME|DKIM|ARC|BIMI)\\b|^[a-z]|-(SPF|FBL|ID|MD5)$|-[a-z]/gi, c => c.toUpperCase()) // special case\n    .replace(/^Content-Features$/i, 'Content-features');\n    return key;\n  }\n  /**\n   * Checks if the content type is multipart and defines boundary if needed.\n   * Doesn't return anything, modifies object argument instead.\n   *\n   * @param {Object} structured Parsed header value for 'Content-Type' key\n   */\n\n\n  _handleContentType(structured) {\n    this.contentType = structured.value.trim().toLowerCase();\n    this.multipart = /^multipart\\//i.test(this.contentType) ? this.contentType.substr(this.contentType.indexOf('/') + 1) : false;\n\n    if (this.multipart) {\n      this.boundary = structured.params.boundary = structured.params.boundary || this.boundary || this._generateBoundary();\n    } else {\n      this.boundary = false;\n    }\n  }\n  /**\n   * Generates a multipart boundary value\n   *\n   * @return {String} boundary value\n   */\n\n\n  _generateBoundary() {\n    return this.rootNode.boundaryPrefix + '-' + this.rootNode.baseBoundary + '-Part_' + this._nodeId;\n  }\n  /**\n   * Encodes a header value for use in the generated rfc2822 email.\n   *\n   * @param {String} key Header key\n   * @param {String} value Header value\n   */\n\n\n  _encodeHeaderValue(key, value) {\n    key = this._normalizeHeaderKey(key);\n\n    switch (key) {\n      // Structured headers\n      case 'From':\n      case 'Sender':\n      case 'To':\n      case 'Cc':\n      case 'Bcc':\n      case 'Reply-To':\n        return this._convertAddresses(this._parseAddresses(value));\n      // values enclosed in <>\n\n      case 'Message-ID':\n      case 'In-Reply-To':\n      case 'Content-Id':\n        value = (value || '').toString().replace(/\\r?\\n|\\r/g, ' ');\n\n        if (value.charAt(0) !== '<') {\n          value = '<' + value;\n        }\n\n        if (value.charAt(value.length - 1) !== '>') {\n          value = value + '>';\n        }\n\n        return value;\n      // space separated list of values enclosed in <>\n\n      case 'References':\n        value = [].concat.apply([], [].concat(value || '').map(elm => {\n          // eslint-disable-line prefer-spread\n          elm = (elm || '').toString().replace(/\\r?\\n|\\r/g, ' ').trim();\n          return elm.replace(/<[^>]*>/g, str => str.replace(/\\s/g, '')).split(/\\s+/);\n        })).map(elm => {\n          if (elm.charAt(0) !== '<') {\n            elm = '<' + elm;\n          }\n\n          if (elm.charAt(elm.length - 1) !== '>') {\n            elm = elm + '>';\n          }\n\n          return elm;\n        });\n        return value.join(' ').trim();\n\n      case 'Date':\n        if (Object.prototype.toString.call(value) === '[object Date]') {\n          return value.toUTCString().replace(/GMT/, '+0000');\n        }\n\n        value = (value || '').toString().replace(/\\r?\\n|\\r/g, ' ');\n        return this._encodeWords(value);\n\n      case 'Content-Type':\n      case 'Content-Disposition':\n        // if it includes a filename then it is already encoded\n        return (value || '').toString().replace(/\\r?\\n|\\r/g, ' ');\n\n      default:\n        value = (value || '').toString().replace(/\\r?\\n|\\r/g, ' '); // encodeWords only encodes if needed, otherwise the original string is returned\n\n        return this._encodeWords(value);\n    }\n  }\n  /**\n   * Rebuilds address object using punycode and other adjustments\n   *\n   * @param {Array} addresses An array of address objects\n   * @param {Array} [uniqueList] An array to be populated with addresses\n   * @return {String} address string\n   */\n\n\n  _convertAddresses(addresses, uniqueList) {\n    let values = [];\n    uniqueList = uniqueList || [];\n    [].concat(addresses || []).forEach(address => {\n      if (address.address) {\n        address.address = this._normalizeAddress(address.address);\n\n        if (!address.name) {\n          values.push(address.address);\n        } else if (address.name) {\n          values.push(this._encodeAddressName(address.name) + ' <' + address.address + '>');\n        }\n\n        if (address.address) {\n          if (!uniqueList.filter(a => a.address === address.address).length) {\n            uniqueList.push(address);\n          }\n        }\n      } else if (address.group) {\n        values.push(this._encodeAddressName(address.name) + ':' + (address.group.length ? this._convertAddresses(address.group, uniqueList) : '').trim() + ';');\n      }\n    });\n    return values.join(', ');\n  }\n  /**\n   * Normalizes an email address\n   *\n   * @param {Array} address An array of address objects\n   * @return {String} address string\n   */\n\n\n  _normalizeAddress(address) {\n    address = (address || '').toString().trim();\n    let lastAt = address.lastIndexOf('@');\n\n    if (lastAt < 0) {\n      // Bare username\n      return address;\n    }\n\n    let user = address.substr(0, lastAt);\n    let domain = address.substr(lastAt + 1); // Usernames are not touched and are kept as is even if these include unicode\n    // Domains are punycoded by default\n    // 'jÃµgeva.ee' will be converted to 'xn--jgeva-dua.ee'\n    // non-unicode domains are left as is\n\n    return user + '@' + punycode.toASCII(domain.toLowerCase());\n  }\n  /**\n   * If needed, mime encodes the name part\n   *\n   * @param {String} name Name part of an address\n   * @returns {String} Mime word encoded string if needed\n   */\n\n\n  _encodeAddressName(name) {\n    if (!/^[\\w ']*$/.test(name)) {\n      if (/^[\\x20-\\x7e]*$/.test(name)) {\n        return '\"' + name.replace(/([\\\\\"])/g, '\\\\$1') + '\"';\n      } else {\n        return mimeFuncs.encodeWord(name, this._getTextEncoding(name), 52);\n      }\n    }\n\n    return name;\n  }\n  /**\n   * If needed, mime encodes the name part\n   *\n   * @param {String} name Name part of an address\n   * @returns {String} Mime word encoded string if needed\n   */\n\n\n  _encodeWords(value) {\n    // set encodeAll parameter to true even though it is against the recommendation of RFC2047,\n    // by default only words that include non-ascii should be converted into encoded words\n    // but some clients (eg. Zimbra) do not handle it properly and remove surrounding whitespace\n    return mimeFuncs.encodeWords(value, this._getTextEncoding(value), 52, true);\n  }\n  /**\n   * Detects best mime encoding for a text value\n   *\n   * @param {String} value Value to check for\n   * @return {String} either 'Q' or 'B'\n   */\n\n\n  _getTextEncoding(value) {\n    value = (value || '').toString();\n    let encoding = this.textEncoding;\n    let latinLen;\n    let nonLatinLen;\n\n    if (!encoding) {\n      // count latin alphabet symbols and 8-bit range symbols + control symbols\n      // if there are more latin characters, then use quoted-printable\n      // encoding, otherwise use base64\n      nonLatinLen = (value.match(/[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\u0080-\\uFFFF]/g) || []).length; // eslint-disable-line no-control-regex\n\n      latinLen = (value.match(/[a-z]/gi) || []).length; // if there are more latin symbols than binary/unicode, then prefer Q, otherwise B\n\n      encoding = nonLatinLen < latinLen ? 'Q' : 'B';\n    }\n\n    return encoding;\n  }\n  /**\n   * Generates a message id\n   *\n   * @return {String} Random Message-ID value\n   */\n\n\n  _generateMessageId() {\n    return '<' + [2, 2, 2, 6].reduce( // crux to generate UUID-like random strings\n    (prev, len) => prev + '-' + crypto.randomBytes(len).toString('hex'), crypto.randomBytes(4).toString('hex')) + '@' + // try to use the domain of the FROM address or fallback to server hostname\n    (this.getEnvelope().from || this.hostname || os.hostname() || 'localhost').split('@').pop() + '>';\n  }\n\n}\n\nmodule.exports = MimeNode;","map":{"version":3,"sources":["C:/Users/Iliyan/Documents/GitHub/Portfolio-Website/Front-End/node_modules/nodemailer/lib/mime-node/index.js"],"names":["crypto","require","os","fs","punycode","PassThrough","shared","mimeFuncs","qp","base64","addressparser","fetch","LastNewline","MimeNode","constructor","contentType","options","nodeCounter","baseBoundary","randomBytes","toString","boundaryPrefix","disableFileAccess","disableUrlAccess","normalizeHeaderKey","date","Date","rootNode","keepBcc","filename","detectMimeType","split","pop","textEncoding","trim","charAt","toUpperCase","parentNode","hostname","childNodes","_nodeId","_headers","_isPlainText","_hasLongLines","_envelope","_raw","_transforms","_processFuncs","setHeader","createChild","undefined","node","appendChild","childNode","push","replace","forEach","i","remove","length","splice","key","value","added","headerValue","Array","isArray","Object","keys","_normalizeHeaderKey","len","addHeader","val","getHeader","setContent","content","pipe","_contentErrorHandler","err","removeListener","once","isPlainText","hasLongerLines","build","callback","promise","Promise","resolve","reject","callbackPromise","stream","createReadStream","buf","buflen","returned","on","chunk","read","Buffer","concat","getTransferEncoding","transferEncoding","toLowerCase","includes","test","_getTextEncoding","buildHeaders","headers","toUTCString","messageId","header","structured","param","formattedHeaders","prepared","foldLines","parseHeaderValue","params","buildHeaderValue","_handleContentType","match","charset","_encodeWords","_encodeHeaderValue","normalized","join","outputStream","transform","emit","end","processFunc","done","contentStream","localStream","finalize","childId","processChildNode","write","boundary","child","setImmediate","multipart","sendContent","prototype","call","createStream","Encoder","_getStream","_resolve","chunks","chunklen","sourceStream","_resolvedValue","raw","setEnvelope","envelope","list","from","to","_convertAddresses","_parseAddresses","filter","address","map","standardFields","getAddresses","addresses","getEnvelope","_generateMessageId","setRaw","path","href","Error","httpHeaders","apply","_normalizeAddress","name","c","substr","indexOf","_generateBoundary","elm","str","uniqueList","values","_encodeAddressName","a","group","lastAt","lastIndexOf","user","domain","toASCII","encodeWord","encodeWords","encoding","latinLen","nonLatinLen","reduce","prev","module","exports"],"mappings":"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","sourcesContent":["/* eslint no-undefined: 0, prefer-spread: 0, no-control-regex: 0 */\n\n'use strict';\n\nconst crypto = require('crypto');\nconst os = require('os');\nconst fs = require('fs');\nconst punycode = require('punycode');\nconst PassThrough = require('stream').PassThrough;\nconst shared = require('../shared');\n\nconst mimeFuncs = require('../mime-funcs');\nconst qp = require('../qp');\nconst base64 = require('../base64');\nconst addressparser = require('../addressparser');\nconst fetch = require('../fetch');\nconst LastNewline = require('./last-newline');\n\n/**\n * Creates a new mime tree node. Assumes 'multipart/*' as the content type\n * if it is a branch, anything else counts as leaf. If rootNode is missing from\n * the options, assumes this is the root.\n *\n * @param {String} contentType Define the content type for the node. Can be left blank for attachments (derived from filename)\n * @param {Object} [options] optional options\n * @param {Object} [options.rootNode] root node for this tree\n * @param {Object} [options.parentNode] immediate parent for this node\n * @param {Object} [options.filename] filename for an attachment node\n * @param {String} [options.baseBoundary] shared part of the unique multipart boundary\n * @param {Boolean} [options.keepBcc] If true, do not exclude Bcc from the generated headers\n * @param {Function} [options.normalizeHeaderKey] method to normalize header keys for custom caseing\n * @param {String} [options.textEncoding] either 'Q' (the default) or 'B'\n */\nclass MimeNode {\n    constructor(contentType, options) {\n        this.nodeCounter = 0;\n\n        options = options || {};\n\n        /**\n         * shared part of the unique multipart boundary\n         */\n        this.baseBoundary = options.baseBoundary || crypto.randomBytes(8).toString('hex');\n        this.boundaryPrefix = options.boundaryPrefix || '--_NmP';\n\n        this.disableFileAccess = !!options.disableFileAccess;\n        this.disableUrlAccess = !!options.disableUrlAccess;\n\n        this.normalizeHeaderKey = options.normalizeHeaderKey;\n\n        /**\n         * If date headers is missing and current node is the root, this value is used instead\n         */\n        this.date = new Date();\n\n        /**\n         * Root node for current mime tree\n         */\n        this.rootNode = options.rootNode || this;\n\n        /**\n         * If true include Bcc in generated headers (if available)\n         */\n        this.keepBcc = !!options.keepBcc;\n\n        /**\n         * If filename is specified but contentType is not (probably an attachment)\n         * detect the content type from filename extension\n         */\n        if (options.filename) {\n            /**\n             * Filename for this node. Useful with attachments\n             */\n            this.filename = options.filename;\n            if (!contentType) {\n                contentType = mimeFuncs.detectMimeType(this.filename.split('.').pop());\n            }\n        }\n\n        /**\n         * Indicates which encoding should be used for header strings: \"Q\" or \"B\"\n         */\n        this.textEncoding = (options.textEncoding || '').toString().trim().charAt(0).toUpperCase();\n\n        /**\n         * Immediate parent for this node (or undefined if not set)\n         */\n        this.parentNode = options.parentNode;\n\n        /**\n         * Hostname for default message-id values\n         */\n        this.hostname = options.hostname;\n\n        /**\n         * An array for possible child nodes\n         */\n        this.childNodes = [];\n\n        /**\n         * Used for generating unique boundaries (prepended to the shared base)\n         */\n        this._nodeId = ++this.rootNode.nodeCounter;\n\n        /**\n         * A list of header values for this node in the form of [{key:'', value:''}]\n         */\n        this._headers = [];\n\n        /**\n         * True if the content only uses ASCII printable characters\n         * @type {Boolean}\n         */\n        this._isPlainText = false;\n\n        /**\n         * True if the content is plain text but has longer lines than allowed\n         * @type {Boolean}\n         */\n        this._hasLongLines = false;\n\n        /**\n         * If set, use instead this value for envelopes instead of generating one\n         * @type {Boolean}\n         */\n        this._envelope = false;\n\n        /**\n         * If set then use this value as the stream content instead of building it\n         * @type {String|Buffer|Stream}\n         */\n        this._raw = false;\n\n        /**\n         * Additional transform streams that the message will be piped before\n         * exposing by createReadStream\n         * @type {Array}\n         */\n        this._transforms = [];\n\n        /**\n         * Additional process functions that the message will be piped through before\n         * exposing by createReadStream. These functions are run after transforms\n         * @type {Array}\n         */\n        this._processFuncs = [];\n\n        /**\n         * If content type is set (or derived from the filename) add it to headers\n         */\n        if (contentType) {\n            this.setHeader('Content-Type', contentType);\n        }\n    }\n\n    /////// PUBLIC METHODS\n\n    /**\n     * Creates and appends a child node.Arguments provided are passed to MimeNode constructor\n     *\n     * @param {String} [contentType] Optional content type\n     * @param {Object} [options] Optional options object\n     * @return {Object} Created node object\n     */\n    createChild(contentType, options) {\n        if (!options && typeof contentType === 'object') {\n            options = contentType;\n            contentType = undefined;\n        }\n        let node = new MimeNode(contentType, options);\n        this.appendChild(node);\n        return node;\n    }\n\n    /**\n     * Appends an existing node to the mime tree. Removes the node from an existing\n     * tree if needed\n     *\n     * @param {Object} childNode node to be appended\n     * @return {Object} Appended node object\n     */\n    appendChild(childNode) {\n        if (childNode.rootNode !== this.rootNode) {\n            childNode.rootNode = this.rootNode;\n            childNode._nodeId = ++this.rootNode.nodeCounter;\n        }\n\n        childNode.parentNode = this;\n\n        this.childNodes.push(childNode);\n        return childNode;\n    }\n\n    /**\n     * Replaces current node with another node\n     *\n     * @param {Object} node Replacement node\n     * @return {Object} Replacement node\n     */\n    replace(node) {\n        if (node === this) {\n            return this;\n        }\n\n        this.parentNode.childNodes.forEach((childNode, i) => {\n            if (childNode === this) {\n                node.rootNode = this.rootNode;\n                node.parentNode = this.parentNode;\n                node._nodeId = this._nodeId;\n\n                this.rootNode = this;\n                this.parentNode = undefined;\n\n                node.parentNode.childNodes[i] = node;\n            }\n        });\n\n        return node;\n    }\n\n    /**\n     * Removes current node from the mime tree\n     *\n     * @return {Object} removed node\n     */\n    remove() {\n        if (!this.parentNode) {\n            return this;\n        }\n\n        for (let i = this.parentNode.childNodes.length - 1; i >= 0; i--) {\n            if (this.parentNode.childNodes[i] === this) {\n                this.parentNode.childNodes.splice(i, 1);\n                this.parentNode = undefined;\n                this.rootNode = this;\n                return this;\n            }\n        }\n    }\n\n    /**\n     * Sets a header value. If the value for selected key exists, it is overwritten.\n     * You can set multiple values as well by using [{key:'', value:''}] or\n     * {key: 'value'} as the first argument.\n     *\n     * @param {String|Array|Object} key Header key or a list of key value pairs\n     * @param {String} value Header value\n     * @return {Object} current node\n     */\n    setHeader(key, value) {\n        let added = false,\n            headerValue;\n\n        // Allow setting multiple headers at once\n        if (!value && key && typeof key === 'object') {\n            // allow {key:'content-type', value: 'text/plain'}\n            if (key.key && 'value' in key) {\n                this.setHeader(key.key, key.value);\n            } else if (Array.isArray(key)) {\n                // allow [{key:'content-type', value: 'text/plain'}]\n                key.forEach(i => {\n                    this.setHeader(i.key, i.value);\n                });\n            } else {\n                // allow {'content-type': 'text/plain'}\n                Object.keys(key).forEach(i => {\n                    this.setHeader(i, key[i]);\n                });\n            }\n            return this;\n        }\n\n        key = this._normalizeHeaderKey(key);\n\n        headerValue = {\n            key,\n            value\n        };\n\n        // Check if the value exists and overwrite\n        for (let i = 0, len = this._headers.length; i < len; i++) {\n            if (this._headers[i].key === key) {\n                if (!added) {\n                    // replace the first match\n                    this._headers[i] = headerValue;\n                    added = true;\n                } else {\n                    // remove following matches\n                    this._headers.splice(i, 1);\n                    i--;\n                    len--;\n                }\n            }\n        }\n\n        // match not found, append the value\n        if (!added) {\n            this._headers.push(headerValue);\n        }\n\n        return this;\n    }\n\n    /**\n     * Adds a header value. If the value for selected key exists, the value is appended\n     * as a new field and old one is not touched.\n     * You can set multiple values as well by using [{key:'', value:''}] or\n     * {key: 'value'} as the first argument.\n     *\n     * @param {String|Array|Object} key Header key or a list of key value pairs\n     * @param {String} value Header value\n     * @return {Object} current node\n     */\n    addHeader(key, value) {\n        // Allow setting multiple headers at once\n        if (!value && key && typeof key === 'object') {\n            // allow {key:'content-type', value: 'text/plain'}\n            if (key.key && key.value) {\n                this.addHeader(key.key, key.value);\n            } else if (Array.isArray(key)) {\n                // allow [{key:'content-type', value: 'text/plain'}]\n                key.forEach(i => {\n                    this.addHeader(i.key, i.value);\n                });\n            } else {\n                // allow {'content-type': 'text/plain'}\n                Object.keys(key).forEach(i => {\n                    this.addHeader(i, key[i]);\n                });\n            }\n            return this;\n        } else if (Array.isArray(value)) {\n            value.forEach(val => {\n                this.addHeader(key, val);\n            });\n            return this;\n        }\n\n        this._headers.push({\n            key: this._normalizeHeaderKey(key),\n            value\n        });\n\n        return this;\n    }\n\n    /**\n     * Retrieves the first mathcing value of a selected key\n     *\n     * @param {String} key Key to search for\n     * @retun {String} Value for the key\n     */\n    getHeader(key) {\n        key = this._normalizeHeaderKey(key);\n        for (let i = 0, len = this._headers.length; i < len; i++) {\n            if (this._headers[i].key === key) {\n                return this._headers[i].value;\n            }\n        }\n    }\n\n    /**\n     * Sets body content for current node. If the value is a string, charset is added automatically\n     * to Content-Type (if it is text/*). If the value is a Buffer, you need to specify\n     * the charset yourself\n     *\n     * @param (String|Buffer) content Body content\n     * @return {Object} current node\n     */\n    setContent(content) {\n        this.content = content;\n        if (typeof this.content.pipe === 'function') {\n            // pre-stream handler. might be triggered if a stream is set as content\n            // and 'error' fires before anything is done with this stream\n            this._contentErrorHandler = err => {\n                this.content.removeListener('error', this._contentErrorHandler);\n                this.content = err;\n            };\n            this.content.once('error', this._contentErrorHandler);\n        } else if (typeof this.content === 'string') {\n            this._isPlainText = mimeFuncs.isPlainText(this.content);\n            if (this._isPlainText && mimeFuncs.hasLongerLines(this.content, 76)) {\n                // If there are lines longer than 76 symbols/bytes do not use 7bit\n                this._hasLongLines = true;\n            }\n        }\n        return this;\n    }\n\n    build(callback) {\n        let promise;\n\n        if (!callback) {\n            promise = new Promise((resolve, reject) => {\n                callback = shared.callbackPromise(resolve, reject);\n            });\n        }\n\n        let stream = this.createReadStream();\n        let buf = [];\n        let buflen = 0;\n        let returned = false;\n\n        stream.on('readable', () => {\n            let chunk;\n\n            while ((chunk = stream.read()) !== null) {\n                buf.push(chunk);\n                buflen += chunk.length;\n            }\n        });\n\n        stream.once('error', err => {\n            if (returned) {\n                return;\n            }\n            returned = true;\n\n            return callback(err);\n        });\n\n        stream.once('end', chunk => {\n            if (returned) {\n                return;\n            }\n            returned = true;\n\n            if (chunk && chunk.length) {\n                buf.push(chunk);\n                buflen += chunk.length;\n            }\n            return callback(null, Buffer.concat(buf, buflen));\n        });\n\n        return promise;\n    }\n\n    getTransferEncoding() {\n        let transferEncoding = false;\n        let contentType = (this.getHeader('Content-Type') || '').toString().toLowerCase().trim();\n\n        if (this.content) {\n            transferEncoding = (this.getHeader('Content-Transfer-Encoding') || '').toString().toLowerCase().trim();\n            if (!transferEncoding || !['base64', 'quoted-printable'].includes(transferEncoding)) {\n                if (/^text\\//i.test(contentType)) {\n                    // If there are no special symbols, no need to modify the text\n                    if (this._isPlainText && !this._hasLongLines) {\n                        transferEncoding = '7bit';\n                    } else if (typeof this.content === 'string' || this.content instanceof Buffer) {\n                        // detect preferred encoding for string value\n                        transferEncoding = this._getTextEncoding(this.content) === 'Q' ? 'quoted-printable' : 'base64';\n                    } else {\n                        // we can not check content for a stream, so either use preferred encoding or fallback to QP\n                        transferEncoding = this.transferEncoding === 'B' ? 'base64' : 'quoted-printable';\n                    }\n                } else if (!/^(multipart|message)\\//i.test(contentType)) {\n                    transferEncoding = transferEncoding || 'base64';\n                }\n            }\n        }\n        return transferEncoding;\n    }\n\n    /**\n     * Builds the header block for the mime node. Append \\r\\n\\r\\n before writing the content\n     *\n     * @returns {String} Headers\n     */\n    buildHeaders() {\n        let transferEncoding = this.getTransferEncoding();\n        let headers = [];\n\n        if (transferEncoding) {\n            this.setHeader('Content-Transfer-Encoding', transferEncoding);\n        }\n\n        if (this.filename && !this.getHeader('Content-Disposition')) {\n            this.setHeader('Content-Disposition', 'attachment');\n        }\n\n        // Ensure mandatory header fields\n        if (this.rootNode === this) {\n            if (!this.getHeader('Date')) {\n                this.setHeader('Date', this.date.toUTCString().replace(/GMT/, '+0000'));\n            }\n\n            // ensure that Message-Id is present\n            this.messageId();\n\n            if (!this.getHeader('MIME-Version')) {\n                this.setHeader('MIME-Version', '1.0');\n            }\n        }\n\n        this._headers.forEach(header => {\n            let key = header.key;\n            let value = header.value;\n            let structured;\n            let param;\n            let options = {};\n            let formattedHeaders = ['From', 'Sender', 'To', 'Cc', 'Bcc', 'Reply-To', 'Date', 'References'];\n\n            if (value && typeof value === 'object' && !formattedHeaders.includes(key)) {\n                Object.keys(value).forEach(key => {\n                    if (key !== 'value') {\n                        options[key] = value[key];\n                    }\n                });\n                value = (value.value || '').toString();\n                if (!value.trim()) {\n                    return;\n                }\n            }\n\n            if (options.prepared) {\n                // header value is\n                if (options.foldLines) {\n                    headers.push(mimeFuncs.foldLines(key + ': ' + value));\n                } else {\n                    headers.push(key + ': ' + value);\n                }\n                return;\n            }\n\n            switch (header.key) {\n                case 'Content-Disposition':\n                    structured = mimeFuncs.parseHeaderValue(value);\n                    if (this.filename) {\n                        structured.params.filename = this.filename;\n                    }\n                    value = mimeFuncs.buildHeaderValue(structured);\n                    break;\n\n                case 'Content-Type':\n                    structured = mimeFuncs.parseHeaderValue(value);\n\n                    this._handleContentType(structured);\n\n                    if (structured.value.match(/^text\\/plain\\b/) && typeof this.content === 'string' && /[\\u0080-\\uFFFF]/.test(this.content)) {\n                        structured.params.charset = 'utf-8';\n                    }\n\n                    value = mimeFuncs.buildHeaderValue(structured);\n\n                    if (this.filename) {\n                        // add support for non-compliant clients like QQ webmail\n                        // we can't build the value with buildHeaderValue as the value is non standard and\n                        // would be converted to parameter continuation encoding that we do not want\n                        param = this._encodeWords(this.filename);\n\n                        if (param !== this.filename || /[\\s'\"\\\\;:/=(),<>@[\\]?]|^-/.test(param)) {\n                            // include value in quotes if needed\n                            param = '\"' + param + '\"';\n                        }\n                        value += '; name=' + param;\n                    }\n                    break;\n\n                case 'Bcc':\n                    if (!this.keepBcc) {\n                        // skip BCC values\n                        return;\n                    }\n                    break;\n            }\n\n            value = this._encodeHeaderValue(key, value);\n\n            // skip empty lines\n            if (!(value || '').toString().trim()) {\n                return;\n            }\n\n            if (typeof this.normalizeHeaderKey === 'function') {\n                let normalized = this.normalizeHeaderKey(key, value);\n                if (normalized && typeof normalized === 'string' && normalized.length) {\n                    key = normalized;\n                }\n            }\n\n            headers.push(mimeFuncs.foldLines(key + ': ' + value, 76));\n        });\n\n        return headers.join('\\r\\n');\n    }\n\n    /**\n     * Streams the rfc2822 message from the current node. If this is a root node,\n     * mandatory header fields are set if missing (Date, Message-Id, MIME-Version)\n     *\n     * @return {String} Compiled message\n     */\n    createReadStream(options) {\n        options = options || {};\n\n        let stream = new PassThrough(options);\n        let outputStream = stream;\n        let transform;\n\n        this.stream(stream, options, err => {\n            if (err) {\n                outputStream.emit('error', err);\n                return;\n            }\n            stream.end();\n        });\n\n        for (let i = 0, len = this._transforms.length; i < len; i++) {\n            transform = typeof this._transforms[i] === 'function' ? this._transforms[i]() : this._transforms[i];\n            outputStream.once('error', err => {\n                transform.emit('error', err);\n            });\n            outputStream = outputStream.pipe(transform);\n        }\n\n        // ensure terminating newline after possible user transforms\n        transform = new LastNewline();\n        outputStream.once('error', err => {\n            transform.emit('error', err);\n        });\n        outputStream = outputStream.pipe(transform);\n\n        // dkim and stuff\n        for (let i = 0, len = this._processFuncs.length; i < len; i++) {\n            transform = this._processFuncs[i];\n            outputStream = transform(outputStream);\n        }\n\n        return outputStream;\n    }\n\n    /**\n     * Appends a transform stream object to the transforms list. Final output\n     * is passed through this stream before exposing\n     *\n     * @param {Object} transform Read-Write stream\n     */\n    transform(transform) {\n        this._transforms.push(transform);\n    }\n\n    /**\n     * Appends a post process function. The functon is run after transforms and\n     * uses the following syntax\n     *\n     *   processFunc(input) -> outputStream\n     *\n     * @param {Object} processFunc Read-Write stream\n     */\n    processFunc(processFunc) {\n        this._processFuncs.push(processFunc);\n    }\n\n    stream(outputStream, options, done) {\n        let transferEncoding = this.getTransferEncoding();\n        let contentStream;\n        let localStream;\n\n        // protect actual callback against multiple triggering\n        let returned = false;\n        let callback = err => {\n            if (returned) {\n                return;\n            }\n            returned = true;\n            done(err);\n        };\n\n        // for multipart nodes, push child nodes\n        // for content nodes end the stream\n        let finalize = () => {\n            let childId = 0;\n            let processChildNode = () => {\n                if (childId >= this.childNodes.length) {\n                    outputStream.write('\\r\\n--' + this.boundary + '--\\r\\n');\n                    return callback();\n                }\n                let child = this.childNodes[childId++];\n                outputStream.write((childId > 1 ? '\\r\\n' : '') + '--' + this.boundary + '\\r\\n');\n                child.stream(outputStream, options, err => {\n                    if (err) {\n                        return callback(err);\n                    }\n                    setImmediate(processChildNode);\n                });\n            };\n\n            if (this.multipart) {\n                setImmediate(processChildNode);\n            } else {\n                return callback();\n            }\n        };\n\n        // pushes node content\n        let sendContent = () => {\n            if (this.content) {\n                if (Object.prototype.toString.call(this.content) === '[object Error]') {\n                    // content is already errored\n                    return callback(this.content);\n                }\n\n                if (typeof this.content.pipe === 'function') {\n                    this.content.removeListener('error', this._contentErrorHandler);\n                    this._contentErrorHandler = err => callback(err);\n                    this.content.once('error', this._contentErrorHandler);\n                }\n\n                let createStream = () => {\n                    if (['quoted-printable', 'base64'].includes(transferEncoding)) {\n                        contentStream = new (transferEncoding === 'base64' ? base64 : qp).Encoder(options);\n\n                        contentStream.pipe(outputStream, {\n                            end: false\n                        });\n                        contentStream.once('end', finalize);\n                        contentStream.once('error', err => callback(err));\n\n                        localStream = this._getStream(this.content);\n                        localStream.pipe(contentStream);\n                    } else {\n                        // anything that is not QP or Base54 passes as-is\n                        localStream = this._getStream(this.content);\n                        localStream.pipe(outputStream, {\n                            end: false\n                        });\n                        localStream.once('end', finalize);\n                    }\n\n                    localStream.once('error', err => callback(err));\n                };\n\n                if (this.content._resolve) {\n                    let chunks = [];\n                    let chunklen = 0;\n                    let returned = false;\n                    let sourceStream = this._getStream(this.content);\n                    sourceStream.on('error', err => {\n                        if (returned) {\n                            return;\n                        }\n                        returned = true;\n                        callback(err);\n                    });\n                    sourceStream.on('readable', () => {\n                        let chunk;\n                        while ((chunk = sourceStream.read()) !== null) {\n                            chunks.push(chunk);\n                            chunklen += chunk.length;\n                        }\n                    });\n                    sourceStream.on('end', () => {\n                        if (returned) {\n                            return;\n                        }\n                        returned = true;\n                        this.content._resolve = false;\n                        this.content._resolvedValue = Buffer.concat(chunks, chunklen);\n                        setImmediate(createStream);\n                    });\n                } else {\n                    setImmediate(createStream);\n                }\n                return;\n            } else {\n                return setImmediate(finalize);\n            }\n        };\n\n        if (this._raw) {\n            setImmediate(() => {\n                if (Object.prototype.toString.call(this._raw) === '[object Error]') {\n                    // content is already errored\n                    return callback(this._raw);\n                }\n\n                // remove default error handler (if set)\n                if (typeof this._raw.pipe === 'function') {\n                    this._raw.removeListener('error', this._contentErrorHandler);\n                }\n\n                let raw = this._getStream(this._raw);\n                raw.pipe(outputStream, {\n                    end: false\n                });\n                raw.on('error', err => outputStream.emit('error', err));\n                raw.on('end', finalize);\n            });\n        } else {\n            outputStream.write(this.buildHeaders() + '\\r\\n\\r\\n');\n            setImmediate(sendContent);\n        }\n    }\n\n    /**\n     * Sets envelope to be used instead of the generated one\n     *\n     * @return {Object} SMTP envelope in the form of {from: 'from@example.com', to: ['to@example.com']}\n     */\n    setEnvelope(envelope) {\n        let list;\n\n        this._envelope = {\n            from: false,\n            to: []\n        };\n\n        if (envelope.from) {\n            list = [];\n            this._convertAddresses(this._parseAddresses(envelope.from), list);\n            list = list.filter(address => address && address.address);\n            if (list.length && list[0]) {\n                this._envelope.from = list[0].address;\n            }\n        }\n        ['to', 'cc', 'bcc'].forEach(key => {\n            if (envelope[key]) {\n                this._convertAddresses(this._parseAddresses(envelope[key]), this._envelope.to);\n            }\n        });\n\n        this._envelope.to = this._envelope.to.map(to => to.address).filter(address => address);\n\n        let standardFields = ['to', 'cc', 'bcc', 'from'];\n        Object.keys(envelope).forEach(key => {\n            if (!standardFields.includes(key)) {\n                this._envelope[key] = envelope[key];\n            }\n        });\n\n        return this;\n    }\n\n    /**\n     * Generates and returns an object with parsed address fields\n     *\n     * @return {Object} Address object\n     */\n    getAddresses() {\n        let addresses = {};\n\n        this._headers.forEach(header => {\n            let key = header.key.toLowerCase();\n            if (['from', 'sender', 'reply-to', 'to', 'cc', 'bcc'].includes(key)) {\n                if (!Array.isArray(addresses[key])) {\n                    addresses[key] = [];\n                }\n\n                this._convertAddresses(this._parseAddresses(header.value), addresses[key]);\n            }\n        });\n\n        return addresses;\n    }\n\n    /**\n     * Generates and returns SMTP envelope with the sender address and a list of recipients addresses\n     *\n     * @return {Object} SMTP envelope in the form of {from: 'from@example.com', to: ['to@example.com']}\n     */\n    getEnvelope() {\n        if (this._envelope) {\n            return this._envelope;\n        }\n\n        let envelope = {\n            from: false,\n            to: []\n        };\n        this._headers.forEach(header => {\n            let list = [];\n            if (header.key === 'From' || (!envelope.from && ['Reply-To', 'Sender'].includes(header.key))) {\n                this._convertAddresses(this._parseAddresses(header.value), list);\n                if (list.length && list[0]) {\n                    envelope.from = list[0].address;\n                }\n            } else if (['To', 'Cc', 'Bcc'].includes(header.key)) {\n                this._convertAddresses(this._parseAddresses(header.value), envelope.to);\n            }\n        });\n\n        envelope.to = envelope.to.map(to => to.address);\n\n        return envelope;\n    }\n\n    /**\n     * Returns Message-Id value. If it does not exist, then creates one\n     *\n     * @return {String} Message-Id value\n     */\n    messageId() {\n        let messageId = this.getHeader('Message-ID');\n        // You really should define your own Message-Id field!\n        if (!messageId) {\n            messageId = this._generateMessageId();\n            this.setHeader('Message-ID', messageId);\n        }\n        return messageId;\n    }\n\n    /**\n     * Sets pregenerated content that will be used as the output of this node\n     *\n     * @param {String|Buffer|Stream} Raw MIME contents\n     */\n    setRaw(raw) {\n        this._raw = raw;\n\n        if (this._raw && typeof this._raw.pipe === 'function') {\n            // pre-stream handler. might be triggered if a stream is set as content\n            // and 'error' fires before anything is done with this stream\n            this._contentErrorHandler = err => {\n                this._raw.removeListener('error', this._contentErrorHandler);\n                this._raw = err;\n            };\n            this._raw.once('error', this._contentErrorHandler);\n        }\n\n        return this;\n    }\n\n    /////// PRIVATE METHODS\n\n    /**\n     * Detects and returns handle to a stream related with the content.\n     *\n     * @param {Mixed} content Node content\n     * @returns {Object} Stream object\n     */\n    _getStream(content) {\n        let contentStream;\n\n        if (content._resolvedValue) {\n            // pass string or buffer content as a stream\n            contentStream = new PassThrough();\n            setImmediate(() => contentStream.end(content._resolvedValue));\n            return contentStream;\n        } else if (typeof content.pipe === 'function') {\n            // assume as stream\n            return content;\n        } else if (content && typeof content.path === 'string' && !content.href) {\n            if (this.disableFileAccess) {\n                contentStream = new PassThrough();\n                setImmediate(() => contentStream.emit('error', new Error('File access rejected for ' + content.path)));\n                return contentStream;\n            }\n            // read file\n            return fs.createReadStream(content.path);\n        } else if (content && typeof content.href === 'string') {\n            if (this.disableUrlAccess) {\n                contentStream = new PassThrough();\n                setImmediate(() => contentStream.emit('error', new Error('Url access rejected for ' + content.href)));\n                return contentStream;\n            }\n            // fetch URL\n            return fetch(content.href, { headers: content.httpHeaders });\n        } else {\n            // pass string or buffer content as a stream\n            contentStream = new PassThrough();\n            setImmediate(() => contentStream.end(content || ''));\n            return contentStream;\n        }\n    }\n\n    /**\n     * Parses addresses. Takes in a single address or an array or an\n     * array of address arrays (eg. To: [[first group], [second group],...])\n     *\n     * @param {Mixed} addresses Addresses to be parsed\n     * @return {Array} An array of address objects\n     */\n    _parseAddresses(addresses) {\n        return [].concat.apply(\n            [],\n            [].concat(addresses).map(address => {\n                // eslint-disable-line prefer-spread\n                if (address && address.address) {\n                    address.address = this._normalizeAddress(address.address);\n                    address.name = address.name || '';\n                    return [address];\n                }\n                return addressparser(address);\n            })\n        );\n    }\n\n    /**\n     * Normalizes a header key, uses Camel-Case form, except for uppercase MIME-\n     *\n     * @param {String} key Key to be normalized\n     * @return {String} key in Camel-Case form\n     */\n    _normalizeHeaderKey(key) {\n        key = (key || '')\n            .toString()\n            // no newlines in keys\n            .replace(/\\r?\\n|\\r/g, ' ')\n            .trim()\n            .toLowerCase()\n            // use uppercase words, except MIME\n            .replace(/^X-SMTPAPI$|^(MIME|DKIM|ARC|BIMI)\\b|^[a-z]|-(SPF|FBL|ID|MD5)$|-[a-z]/gi, c => c.toUpperCase())\n            // special case\n            .replace(/^Content-Features$/i, 'Content-features');\n\n        return key;\n    }\n\n    /**\n     * Checks if the content type is multipart and defines boundary if needed.\n     * Doesn't return anything, modifies object argument instead.\n     *\n     * @param {Object} structured Parsed header value for 'Content-Type' key\n     */\n    _handleContentType(structured) {\n        this.contentType = structured.value.trim().toLowerCase();\n\n        this.multipart = /^multipart\\//i.test(this.contentType) ? this.contentType.substr(this.contentType.indexOf('/') + 1) : false;\n\n        if (this.multipart) {\n            this.boundary = structured.params.boundary = structured.params.boundary || this.boundary || this._generateBoundary();\n        } else {\n            this.boundary = false;\n        }\n    }\n\n    /**\n     * Generates a multipart boundary value\n     *\n     * @return {String} boundary value\n     */\n    _generateBoundary() {\n        return this.rootNode.boundaryPrefix + '-' + this.rootNode.baseBoundary + '-Part_' + this._nodeId;\n    }\n\n    /**\n     * Encodes a header value for use in the generated rfc2822 email.\n     *\n     * @param {String} key Header key\n     * @param {String} value Header value\n     */\n    _encodeHeaderValue(key, value) {\n        key = this._normalizeHeaderKey(key);\n\n        switch (key) {\n            // Structured headers\n            case 'From':\n            case 'Sender':\n            case 'To':\n            case 'Cc':\n            case 'Bcc':\n            case 'Reply-To':\n                return this._convertAddresses(this._parseAddresses(value));\n\n            // values enclosed in <>\n            case 'Message-ID':\n            case 'In-Reply-To':\n            case 'Content-Id':\n                value = (value || '').toString().replace(/\\r?\\n|\\r/g, ' ');\n\n                if (value.charAt(0) !== '<') {\n                    value = '<' + value;\n                }\n\n                if (value.charAt(value.length - 1) !== '>') {\n                    value = value + '>';\n                }\n                return value;\n\n            // space separated list of values enclosed in <>\n            case 'References':\n                value = [].concat\n                    .apply(\n                        [],\n                        [].concat(value || '').map(elm => {\n                            // eslint-disable-line prefer-spread\n                            elm = (elm || '')\n                                .toString()\n                                .replace(/\\r?\\n|\\r/g, ' ')\n                                .trim();\n                            return elm.replace(/<[^>]*>/g, str => str.replace(/\\s/g, '')).split(/\\s+/);\n                        })\n                    )\n                    .map(elm => {\n                        if (elm.charAt(0) !== '<') {\n                            elm = '<' + elm;\n                        }\n                        if (elm.charAt(elm.length - 1) !== '>') {\n                            elm = elm + '>';\n                        }\n                        return elm;\n                    });\n\n                return value.join(' ').trim();\n\n            case 'Date':\n                if (Object.prototype.toString.call(value) === '[object Date]') {\n                    return value.toUTCString().replace(/GMT/, '+0000');\n                }\n\n                value = (value || '').toString().replace(/\\r?\\n|\\r/g, ' ');\n                return this._encodeWords(value);\n\n            case 'Content-Type':\n            case 'Content-Disposition':\n                // if it includes a filename then it is already encoded\n                return (value || '').toString().replace(/\\r?\\n|\\r/g, ' ');\n\n            default:\n                value = (value || '').toString().replace(/\\r?\\n|\\r/g, ' ');\n                // encodeWords only encodes if needed, otherwise the original string is returned\n                return this._encodeWords(value);\n        }\n    }\n\n    /**\n     * Rebuilds address object using punycode and other adjustments\n     *\n     * @param {Array} addresses An array of address objects\n     * @param {Array} [uniqueList] An array to be populated with addresses\n     * @return {String} address string\n     */\n    _convertAddresses(addresses, uniqueList) {\n        let values = [];\n\n        uniqueList = uniqueList || [];\n\n        [].concat(addresses || []).forEach(address => {\n            if (address.address) {\n                address.address = this._normalizeAddress(address.address);\n\n                if (!address.name) {\n                    values.push(address.address);\n                } else if (address.name) {\n                    values.push(this._encodeAddressName(address.name) + ' <' + address.address + '>');\n                }\n\n                if (address.address) {\n                    if (!uniqueList.filter(a => a.address === address.address).length) {\n                        uniqueList.push(address);\n                    }\n                }\n            } else if (address.group) {\n                values.push(\n                    this._encodeAddressName(address.name) + ':' + (address.group.length ? this._convertAddresses(address.group, uniqueList) : '').trim() + ';'\n                );\n            }\n        });\n\n        return values.join(', ');\n    }\n\n    /**\n     * Normalizes an email address\n     *\n     * @param {Array} address An array of address objects\n     * @return {String} address string\n     */\n    _normalizeAddress(address) {\n        address = (address || '').toString().trim();\n\n        let lastAt = address.lastIndexOf('@');\n        if (lastAt < 0) {\n            // Bare username\n            return address;\n        }\n        let user = address.substr(0, lastAt);\n        let domain = address.substr(lastAt + 1);\n\n        // Usernames are not touched and are kept as is even if these include unicode\n        // Domains are punycoded by default\n        // 'jÃµgeva.ee' will be converted to 'xn--jgeva-dua.ee'\n        // non-unicode domains are left as is\n\n        return user + '@' + punycode.toASCII(domain.toLowerCase());\n    }\n\n    /**\n     * If needed, mime encodes the name part\n     *\n     * @param {String} name Name part of an address\n     * @returns {String} Mime word encoded string if needed\n     */\n    _encodeAddressName(name) {\n        if (!/^[\\w ']*$/.test(name)) {\n            if (/^[\\x20-\\x7e]*$/.test(name)) {\n                return '\"' + name.replace(/([\\\\\"])/g, '\\\\$1') + '\"';\n            } else {\n                return mimeFuncs.encodeWord(name, this._getTextEncoding(name), 52);\n            }\n        }\n        return name;\n    }\n\n    /**\n     * If needed, mime encodes the name part\n     *\n     * @param {String} name Name part of an address\n     * @returns {String} Mime word encoded string if needed\n     */\n    _encodeWords(value) {\n        // set encodeAll parameter to true even though it is against the recommendation of RFC2047,\n        // by default only words that include non-ascii should be converted into encoded words\n        // but some clients (eg. Zimbra) do not handle it properly and remove surrounding whitespace\n        return mimeFuncs.encodeWords(value, this._getTextEncoding(value), 52, true);\n    }\n\n    /**\n     * Detects best mime encoding for a text value\n     *\n     * @param {String} value Value to check for\n     * @return {String} either 'Q' or 'B'\n     */\n    _getTextEncoding(value) {\n        value = (value || '').toString();\n\n        let encoding = this.textEncoding;\n        let latinLen;\n        let nonLatinLen;\n\n        if (!encoding) {\n            // count latin alphabet symbols and 8-bit range symbols + control symbols\n            // if there are more latin characters, then use quoted-printable\n            // encoding, otherwise use base64\n            nonLatinLen = (value.match(/[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\u0080-\\uFFFF]/g) || []).length; // eslint-disable-line no-control-regex\n            latinLen = (value.match(/[a-z]/gi) || []).length;\n            // if there are more latin symbols than binary/unicode, then prefer Q, otherwise B\n            encoding = nonLatinLen < latinLen ? 'Q' : 'B';\n        }\n        return encoding;\n    }\n\n    /**\n     * Generates a message id\n     *\n     * @return {String} Random Message-ID value\n     */\n    _generateMessageId() {\n        return (\n            '<' +\n            [2, 2, 2, 6].reduce(\n                // crux to generate UUID-like random strings\n                (prev, len) => prev + '-' + crypto.randomBytes(len).toString('hex'),\n                crypto.randomBytes(4).toString('hex')\n            ) +\n            '@' +\n            // try to use the domain of the FROM address or fallback to server hostname\n            (this.getEnvelope().from || this.hostname || os.hostname() || 'localhost').split('@').pop() +\n            '>'\n        );\n    }\n}\n\nmodule.exports = MimeNode;\n"]},"metadata":{},"sourceType":"script"}