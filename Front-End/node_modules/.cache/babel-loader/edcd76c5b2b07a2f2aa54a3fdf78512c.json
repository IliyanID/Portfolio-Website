{"ast":null,"code":"'use strict';\n\nconst http = require('http');\n\nconst https = require('https');\n\nconst urllib = require('url');\n\nconst zlib = require('zlib');\n\nconst PassThrough = require('stream').PassThrough;\n\nconst Cookies = require('./cookies');\n\nconst packageData = require('../../package.json');\n\nconst MAX_REDIRECTS = 5;\n\nmodule.exports = function (url, options) {\n  return fetch(url, options);\n};\n\nmodule.exports.Cookies = Cookies;\n\nfunction fetch(url, options) {\n  options = options || {};\n  options.fetchRes = options.fetchRes || new PassThrough();\n  options.cookies = options.cookies || new Cookies();\n  options.redirects = options.redirects || 0;\n  options.maxRedirects = isNaN(options.maxRedirects) ? MAX_REDIRECTS : options.maxRedirects;\n\n  if (options.cookie) {\n    [].concat(options.cookie || []).forEach(cookie => {\n      options.cookies.set(cookie, url);\n    });\n    options.cookie = false;\n  }\n\n  let fetchRes = options.fetchRes;\n  let parsed = urllib.parse(url);\n  let method = (options.method || '').toString().trim().toUpperCase() || 'GET';\n  let finished = false;\n  let cookies;\n  let body;\n  let handler = parsed.protocol === 'https:' ? https : http;\n  let headers = {\n    'accept-encoding': 'gzip,deflate',\n    'user-agent': 'nodemailer/' + packageData.version\n  };\n  Object.keys(options.headers || {}).forEach(key => {\n    headers[key.toLowerCase().trim()] = options.headers[key];\n  });\n\n  if (options.userAgent) {\n    headers['user-agent'] = options.userAgent;\n  }\n\n  if (parsed.auth) {\n    headers.Authorization = 'Basic ' + Buffer.from(parsed.auth).toString('base64');\n  }\n\n  if (cookies = options.cookies.get(url)) {\n    headers.cookie = cookies;\n  }\n\n  if (options.body) {\n    if (options.contentType !== false) {\n      headers['Content-Type'] = options.contentType || 'application/x-www-form-urlencoded';\n    }\n\n    if (typeof options.body.pipe === 'function') {\n      // it's a stream\n      headers['Transfer-Encoding'] = 'chunked';\n      body = options.body;\n      body.on('error', err => {\n        if (finished) {\n          return;\n        }\n\n        finished = true;\n        err.type = 'FETCH';\n        err.sourceUrl = url;\n        fetchRes.emit('error', err);\n      });\n    } else {\n      if (options.body instanceof Buffer) {\n        body = options.body;\n      } else if (typeof options.body === 'object') {\n        try {\n          // encodeURIComponent can fail on invalid input (partial emoji etc.)\n          body = Buffer.from(Object.keys(options.body).map(key => {\n            let value = options.body[key].toString().trim();\n            return encodeURIComponent(key) + '=' + encodeURIComponent(value);\n          }).join('&'));\n        } catch (E) {\n          if (finished) {\n            return;\n          }\n\n          finished = true;\n          E.type = 'FETCH';\n          E.sourceUrl = url;\n          fetchRes.emit('error', E);\n          return;\n        }\n      } else {\n        body = Buffer.from(options.body.toString().trim());\n      }\n\n      headers['Content-Type'] = options.contentType || 'application/x-www-form-urlencoded';\n      headers['Content-Length'] = body.length;\n    } // if method is not provided, use POST instead of GET\n\n\n    method = (options.method || '').toString().trim().toUpperCase() || 'POST';\n  }\n\n  let req;\n  let reqOptions = {\n    method,\n    host: parsed.hostname,\n    path: parsed.path,\n    port: parsed.port ? parsed.port : parsed.protocol === 'https:' ? 443 : 80,\n    headers,\n    rejectUnauthorized: false,\n    agent: false\n  };\n\n  if (options.tls) {\n    Object.keys(options.tls).forEach(key => {\n      reqOptions[key] = options.tls[key];\n    });\n  }\n\n  try {\n    req = handler.request(reqOptions);\n  } catch (E) {\n    finished = true;\n    setImmediate(() => {\n      E.type = 'FETCH';\n      E.sourceUrl = url;\n      fetchRes.emit('error', E);\n    });\n    return fetchRes;\n  }\n\n  if (options.timeout) {\n    req.setTimeout(options.timeout, () => {\n      if (finished) {\n        return;\n      }\n\n      finished = true;\n      req.abort();\n      let err = new Error('Request Timeout');\n      err.type = 'FETCH';\n      err.sourceUrl = url;\n      fetchRes.emit('error', err);\n    });\n  }\n\n  req.on('error', err => {\n    if (finished) {\n      return;\n    }\n\n    finished = true;\n    err.type = 'FETCH';\n    err.sourceUrl = url;\n    fetchRes.emit('error', err);\n  });\n  req.on('response', res => {\n    let inflate;\n\n    if (finished) {\n      return;\n    }\n\n    switch (res.headers['content-encoding']) {\n      case 'gzip':\n      case 'deflate':\n        inflate = zlib.createUnzip();\n        break;\n    }\n\n    if (res.headers['set-cookie']) {\n      [].concat(res.headers['set-cookie'] || []).forEach(cookie => {\n        options.cookies.set(cookie, url);\n      });\n    }\n\n    if ([301, 302, 303, 307, 308].includes(res.statusCode) && res.headers.location) {\n      // redirect\n      options.redirects++;\n\n      if (options.redirects > options.maxRedirects) {\n        finished = true;\n        let err = new Error('Maximum redirect count exceeded');\n        err.type = 'FETCH';\n        err.sourceUrl = url;\n        fetchRes.emit('error', err);\n        req.abort();\n        return;\n      } // redirect does not include POST body\n\n\n      options.method = 'GET';\n      options.body = false;\n      return fetch(urllib.resolve(url, res.headers.location), options);\n    }\n\n    fetchRes.statusCode = res.statusCode;\n    fetchRes.headers = res.headers;\n\n    if (res.statusCode >= 300 && !options.allowErrorResponse) {\n      finished = true;\n      let err = new Error('Invalid status code ' + res.statusCode);\n      err.type = 'FETCH';\n      err.sourceUrl = url;\n      fetchRes.emit('error', err);\n      req.abort();\n      return;\n    }\n\n    res.on('error', err => {\n      if (finished) {\n        return;\n      }\n\n      finished = true;\n      err.type = 'FETCH';\n      err.sourceUrl = url;\n      fetchRes.emit('error', err);\n      req.abort();\n    });\n\n    if (inflate) {\n      res.pipe(inflate).pipe(fetchRes);\n      inflate.on('error', err => {\n        if (finished) {\n          return;\n        }\n\n        finished = true;\n        err.type = 'FETCH';\n        err.sourceUrl = url;\n        fetchRes.emit('error', err);\n        req.abort();\n      });\n    } else {\n      res.pipe(fetchRes);\n    }\n  });\n  setImmediate(() => {\n    if (body) {\n      try {\n        if (typeof body.pipe === 'function') {\n          return body.pipe(req);\n        } else {\n          req.write(body);\n        }\n      } catch (err) {\n        finished = true;\n        err.type = 'FETCH';\n        err.sourceUrl = url;\n        fetchRes.emit('error', err);\n        return;\n      }\n    }\n\n    req.end();\n  });\n  return fetchRes;\n}","map":{"version":3,"sources":["C:/Users/Iliyan/Documents/GitHub/Portfolio-Website/Front-End/node_modules/nodemailer/lib/fetch/index.js"],"names":["http","require","https","urllib","zlib","PassThrough","Cookies","packageData","MAX_REDIRECTS","module","exports","url","options","fetch","fetchRes","cookies","redirects","maxRedirects","isNaN","cookie","concat","forEach","set","parsed","parse","method","toString","trim","toUpperCase","finished","body","handler","protocol","headers","version","Object","keys","key","toLowerCase","userAgent","auth","Authorization","Buffer","from","get","contentType","pipe","on","err","type","sourceUrl","emit","map","value","encodeURIComponent","join","E","length","req","reqOptions","host","hostname","path","port","rejectUnauthorized","agent","tls","request","setImmediate","timeout","setTimeout","abort","Error","res","inflate","createUnzip","includes","statusCode","location","resolve","allowErrorResponse","write","end"],"mappings":"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","sourcesContent":["'use strict';\n\nconst http = require('http');\nconst https = require('https');\nconst urllib = require('url');\nconst zlib = require('zlib');\nconst PassThrough = require('stream').PassThrough;\nconst Cookies = require('./cookies');\nconst packageData = require('../../package.json');\n\nconst MAX_REDIRECTS = 5;\n\nmodule.exports = function (url, options) {\n    return fetch(url, options);\n};\n\nmodule.exports.Cookies = Cookies;\n\nfunction fetch(url, options) {\n    options = options || {};\n\n    options.fetchRes = options.fetchRes || new PassThrough();\n    options.cookies = options.cookies || new Cookies();\n    options.redirects = options.redirects || 0;\n    options.maxRedirects = isNaN(options.maxRedirects) ? MAX_REDIRECTS : options.maxRedirects;\n\n    if (options.cookie) {\n        [].concat(options.cookie || []).forEach(cookie => {\n            options.cookies.set(cookie, url);\n        });\n        options.cookie = false;\n    }\n\n    let fetchRes = options.fetchRes;\n    let parsed = urllib.parse(url);\n    let method = (options.method || '').toString().trim().toUpperCase() || 'GET';\n    let finished = false;\n    let cookies;\n    let body;\n\n    let handler = parsed.protocol === 'https:' ? https : http;\n\n    let headers = {\n        'accept-encoding': 'gzip,deflate',\n        'user-agent': 'nodemailer/' + packageData.version\n    };\n\n    Object.keys(options.headers || {}).forEach(key => {\n        headers[key.toLowerCase().trim()] = options.headers[key];\n    });\n\n    if (options.userAgent) {\n        headers['user-agent'] = options.userAgent;\n    }\n\n    if (parsed.auth) {\n        headers.Authorization = 'Basic ' + Buffer.from(parsed.auth).toString('base64');\n    }\n\n    if ((cookies = options.cookies.get(url))) {\n        headers.cookie = cookies;\n    }\n\n    if (options.body) {\n        if (options.contentType !== false) {\n            headers['Content-Type'] = options.contentType || 'application/x-www-form-urlencoded';\n        }\n\n        if (typeof options.body.pipe === 'function') {\n            // it's a stream\n            headers['Transfer-Encoding'] = 'chunked';\n            body = options.body;\n            body.on('error', err => {\n                if (finished) {\n                    return;\n                }\n                finished = true;\n                err.type = 'FETCH';\n                err.sourceUrl = url;\n                fetchRes.emit('error', err);\n            });\n        } else {\n            if (options.body instanceof Buffer) {\n                body = options.body;\n            } else if (typeof options.body === 'object') {\n                try {\n                    // encodeURIComponent can fail on invalid input (partial emoji etc.)\n                    body = Buffer.from(\n                        Object.keys(options.body)\n                            .map(key => {\n                                let value = options.body[key].toString().trim();\n                                return encodeURIComponent(key) + '=' + encodeURIComponent(value);\n                            })\n                            .join('&')\n                    );\n                } catch (E) {\n                    if (finished) {\n                        return;\n                    }\n                    finished = true;\n                    E.type = 'FETCH';\n                    E.sourceUrl = url;\n                    fetchRes.emit('error', E);\n                    return;\n                }\n            } else {\n                body = Buffer.from(options.body.toString().trim());\n            }\n\n            headers['Content-Type'] = options.contentType || 'application/x-www-form-urlencoded';\n            headers['Content-Length'] = body.length;\n        }\n        // if method is not provided, use POST instead of GET\n        method = (options.method || '').toString().trim().toUpperCase() || 'POST';\n    }\n\n    let req;\n    let reqOptions = {\n        method,\n        host: parsed.hostname,\n        path: parsed.path,\n        port: parsed.port ? parsed.port : parsed.protocol === 'https:' ? 443 : 80,\n        headers,\n        rejectUnauthorized: false,\n        agent: false\n    };\n\n    if (options.tls) {\n        Object.keys(options.tls).forEach(key => {\n            reqOptions[key] = options.tls[key];\n        });\n    }\n\n    try {\n        req = handler.request(reqOptions);\n    } catch (E) {\n        finished = true;\n        setImmediate(() => {\n            E.type = 'FETCH';\n            E.sourceUrl = url;\n            fetchRes.emit('error', E);\n        });\n        return fetchRes;\n    }\n\n    if (options.timeout) {\n        req.setTimeout(options.timeout, () => {\n            if (finished) {\n                return;\n            }\n            finished = true;\n            req.abort();\n            let err = new Error('Request Timeout');\n            err.type = 'FETCH';\n            err.sourceUrl = url;\n            fetchRes.emit('error', err);\n        });\n    }\n\n    req.on('error', err => {\n        if (finished) {\n            return;\n        }\n        finished = true;\n        err.type = 'FETCH';\n        err.sourceUrl = url;\n        fetchRes.emit('error', err);\n    });\n\n    req.on('response', res => {\n        let inflate;\n\n        if (finished) {\n            return;\n        }\n\n        switch (res.headers['content-encoding']) {\n            case 'gzip':\n            case 'deflate':\n                inflate = zlib.createUnzip();\n                break;\n        }\n\n        if (res.headers['set-cookie']) {\n            [].concat(res.headers['set-cookie'] || []).forEach(cookie => {\n                options.cookies.set(cookie, url);\n            });\n        }\n\n        if ([301, 302, 303, 307, 308].includes(res.statusCode) && res.headers.location) {\n            // redirect\n            options.redirects++;\n            if (options.redirects > options.maxRedirects) {\n                finished = true;\n                let err = new Error('Maximum redirect count exceeded');\n                err.type = 'FETCH';\n                err.sourceUrl = url;\n                fetchRes.emit('error', err);\n                req.abort();\n                return;\n            }\n            // redirect does not include POST body\n            options.method = 'GET';\n            options.body = false;\n            return fetch(urllib.resolve(url, res.headers.location), options);\n        }\n\n        fetchRes.statusCode = res.statusCode;\n        fetchRes.headers = res.headers;\n\n        if (res.statusCode >= 300 && !options.allowErrorResponse) {\n            finished = true;\n            let err = new Error('Invalid status code ' + res.statusCode);\n            err.type = 'FETCH';\n            err.sourceUrl = url;\n            fetchRes.emit('error', err);\n            req.abort();\n            return;\n        }\n\n        res.on('error', err => {\n            if (finished) {\n                return;\n            }\n            finished = true;\n            err.type = 'FETCH';\n            err.sourceUrl = url;\n            fetchRes.emit('error', err);\n            req.abort();\n        });\n\n        if (inflate) {\n            res.pipe(inflate).pipe(fetchRes);\n            inflate.on('error', err => {\n                if (finished) {\n                    return;\n                }\n                finished = true;\n                err.type = 'FETCH';\n                err.sourceUrl = url;\n                fetchRes.emit('error', err);\n                req.abort();\n            });\n        } else {\n            res.pipe(fetchRes);\n        }\n    });\n\n    setImmediate(() => {\n        if (body) {\n            try {\n                if (typeof body.pipe === 'function') {\n                    return body.pipe(req);\n                } else {\n                    req.write(body);\n                }\n            } catch (err) {\n                finished = true;\n                err.type = 'FETCH';\n                err.sourceUrl = url;\n                fetchRes.emit('error', err);\n                return;\n            }\n        }\n        req.end();\n    });\n\n    return fetchRes;\n}\n"]},"metadata":{},"sourceType":"script"}