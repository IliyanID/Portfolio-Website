{"ast":null,"code":"'use strict';\n\nconst punycode = require('punycode');\n\nconst mimeFuncs = require('../mime-funcs');\n\nconst crypto = require('crypto');\n/**\n * Returns DKIM signature header line\n *\n * @param {Object} headers Parsed headers object from MessageParser\n * @param {String} bodyHash Base64 encoded hash of the message\n * @param {Object} options DKIM options\n * @param {String} options.domainName Domain name to be signed for\n * @param {String} options.keySelector DKIM key selector to use\n * @param {String} options.privateKey DKIM private key to use\n * @return {String} Complete header line\n */\n\n\nmodule.exports = (headers, hashAlgo, bodyHash, options) => {\n  options = options || {}; // all listed fields from RFC4871 #5.5\n\n  let defaultFieldNames = 'From:Sender:Reply-To:Subject:Date:Message-ID:To:' + 'Cc:MIME-Version:Content-Type:Content-Transfer-Encoding:Content-ID:' + 'Content-Description:Resent-Date:Resent-From:Resent-Sender:' + 'Resent-To:Resent-Cc:Resent-Message-ID:In-Reply-To:References:' + 'List-Id:List-Help:List-Unsubscribe:List-Subscribe:List-Post:' + 'List-Owner:List-Archive';\n  let fieldNames = options.headerFieldNames || defaultFieldNames;\n  let canonicalizedHeaderData = relaxedHeaders(headers, fieldNames, options.skipFields);\n  let dkimHeader = generateDKIMHeader(options.domainName, options.keySelector, canonicalizedHeaderData.fieldNames, hashAlgo, bodyHash);\n  let signer, signature;\n  canonicalizedHeaderData.headers += 'dkim-signature:' + relaxedHeaderLine(dkimHeader);\n  signer = crypto.createSign(('rsa-' + hashAlgo).toUpperCase());\n  signer.update(canonicalizedHeaderData.headers);\n\n  try {\n    signature = signer.sign(options.privateKey, 'base64');\n  } catch (E) {\n    return false;\n  }\n\n  return dkimHeader + signature.replace(/(^.{73}|.{75}(?!\\r?\\n|\\r))/g, '$&\\r\\n ').trim();\n};\n\nmodule.exports.relaxedHeaders = relaxedHeaders;\n\nfunction generateDKIMHeader(domainName, keySelector, fieldNames, hashAlgo, bodyHash) {\n  let dkim = ['v=1', 'a=rsa-' + hashAlgo, 'c=relaxed/relaxed', 'd=' + punycode.toASCII(domainName), 'q=dns/txt', 's=' + keySelector, 'bh=' + bodyHash, 'h=' + fieldNames].join('; ');\n  return mimeFuncs.foldLines('DKIM-Signature: ' + dkim, 76) + ';\\r\\n b=';\n}\n\nfunction relaxedHeaders(headers, fieldNames, skipFields) {\n  let includedFields = new Set();\n  let skip = new Set();\n  let headerFields = new Map();\n  (skipFields || '').toLowerCase().split(':').forEach(field => {\n    skip.add(field.trim());\n  });\n  (fieldNames || '').toLowerCase().split(':').filter(field => !skip.has(field.trim())).forEach(field => {\n    includedFields.add(field.trim());\n  });\n\n  for (let i = headers.length - 1; i >= 0; i--) {\n    let line = headers[i]; // only include the first value from bottom to top\n\n    if (includedFields.has(line.key) && !headerFields.has(line.key)) {\n      headerFields.set(line.key, relaxedHeaderLine(line.line));\n    }\n  }\n\n  let headersList = [];\n  let fields = [];\n  includedFields.forEach(field => {\n    if (headerFields.has(field)) {\n      fields.push(field);\n      headersList.push(field + ':' + headerFields.get(field));\n    }\n  });\n  return {\n    headers: headersList.join('\\r\\n') + '\\r\\n',\n    fieldNames: fields.join(':')\n  };\n}\n\nfunction relaxedHeaderLine(line) {\n  return line.substr(line.indexOf(':') + 1).replace(/\\r?\\n/g, '').replace(/\\s+/g, ' ').trim();\n}","map":{"version":3,"sources":["C:/Users/Iliyan/Documents/GitHub/Portfolio-Website/Front-End/node_modules/nodemailer/lib/dkim/sign.js"],"names":["punycode","require","mimeFuncs","crypto","module","exports","headers","hashAlgo","bodyHash","options","defaultFieldNames","fieldNames","headerFieldNames","canonicalizedHeaderData","relaxedHeaders","skipFields","dkimHeader","generateDKIMHeader","domainName","keySelector","signer","signature","relaxedHeaderLine","createSign","toUpperCase","update","sign","privateKey","E","replace","trim","dkim","toASCII","join","foldLines","includedFields","Set","skip","headerFields","Map","toLowerCase","split","forEach","field","add","filter","has","i","length","line","key","set","headersList","fields","push","get","substr","indexOf"],"mappings":"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","sourcesContent":["'use strict';\n\nconst punycode = require('punycode');\nconst mimeFuncs = require('../mime-funcs');\nconst crypto = require('crypto');\n\n/**\n * Returns DKIM signature header line\n *\n * @param {Object} headers Parsed headers object from MessageParser\n * @param {String} bodyHash Base64 encoded hash of the message\n * @param {Object} options DKIM options\n * @param {String} options.domainName Domain name to be signed for\n * @param {String} options.keySelector DKIM key selector to use\n * @param {String} options.privateKey DKIM private key to use\n * @return {String} Complete header line\n */\n\nmodule.exports = (headers, hashAlgo, bodyHash, options) => {\n    options = options || {};\n\n    // all listed fields from RFC4871 #5.5\n    let defaultFieldNames =\n        'From:Sender:Reply-To:Subject:Date:Message-ID:To:' +\n        'Cc:MIME-Version:Content-Type:Content-Transfer-Encoding:Content-ID:' +\n        'Content-Description:Resent-Date:Resent-From:Resent-Sender:' +\n        'Resent-To:Resent-Cc:Resent-Message-ID:In-Reply-To:References:' +\n        'List-Id:List-Help:List-Unsubscribe:List-Subscribe:List-Post:' +\n        'List-Owner:List-Archive';\n\n    let fieldNames = options.headerFieldNames || defaultFieldNames;\n\n    let canonicalizedHeaderData = relaxedHeaders(headers, fieldNames, options.skipFields);\n    let dkimHeader = generateDKIMHeader(options.domainName, options.keySelector, canonicalizedHeaderData.fieldNames, hashAlgo, bodyHash);\n\n    let signer, signature;\n\n    canonicalizedHeaderData.headers += 'dkim-signature:' + relaxedHeaderLine(dkimHeader);\n\n    signer = crypto.createSign(('rsa-' + hashAlgo).toUpperCase());\n    signer.update(canonicalizedHeaderData.headers);\n    try {\n        signature = signer.sign(options.privateKey, 'base64');\n    } catch (E) {\n        return false;\n    }\n\n    return dkimHeader + signature.replace(/(^.{73}|.{75}(?!\\r?\\n|\\r))/g, '$&\\r\\n ').trim();\n};\n\nmodule.exports.relaxedHeaders = relaxedHeaders;\n\nfunction generateDKIMHeader(domainName, keySelector, fieldNames, hashAlgo, bodyHash) {\n    let dkim = [\n        'v=1',\n        'a=rsa-' + hashAlgo,\n        'c=relaxed/relaxed',\n        'd=' + punycode.toASCII(domainName),\n        'q=dns/txt',\n        's=' + keySelector,\n        'bh=' + bodyHash,\n        'h=' + fieldNames\n    ].join('; ');\n\n    return mimeFuncs.foldLines('DKIM-Signature: ' + dkim, 76) + ';\\r\\n b=';\n}\n\nfunction relaxedHeaders(headers, fieldNames, skipFields) {\n    let includedFields = new Set();\n    let skip = new Set();\n    let headerFields = new Map();\n\n    (skipFields || '')\n        .toLowerCase()\n        .split(':')\n        .forEach(field => {\n            skip.add(field.trim());\n        });\n\n    (fieldNames || '')\n        .toLowerCase()\n        .split(':')\n        .filter(field => !skip.has(field.trim()))\n        .forEach(field => {\n            includedFields.add(field.trim());\n        });\n\n    for (let i = headers.length - 1; i >= 0; i--) {\n        let line = headers[i];\n        // only include the first value from bottom to top\n        if (includedFields.has(line.key) && !headerFields.has(line.key)) {\n            headerFields.set(line.key, relaxedHeaderLine(line.line));\n        }\n    }\n\n    let headersList = [];\n    let fields = [];\n    includedFields.forEach(field => {\n        if (headerFields.has(field)) {\n            fields.push(field);\n            headersList.push(field + ':' + headerFields.get(field));\n        }\n    });\n\n    return {\n        headers: headersList.join('\\r\\n') + '\\r\\n',\n        fieldNames: fields.join(':')\n    };\n}\n\nfunction relaxedHeaderLine(line) {\n    return line\n        .substr(line.indexOf(':') + 1)\n        .replace(/\\r?\\n/g, '')\n        .replace(/\\s+/g, ' ')\n        .trim();\n}\n"]},"metadata":{},"sourceType":"script"}